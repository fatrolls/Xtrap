/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

CTcpLine *__thiscall CTcpLine::CTcpLine(CTcpLine *this);
CTcpLine *__thiscall CTcpLine::`scalar deleting destructor'(CTcpLine *this, char a2);
void __thiscall CTcpLine::~CTcpLine(CTcpLine *__hidden this); // idb
BOOL __cdecl XTrapClient_Connect(struct CTcpLine *a1, struct in_addr in, unsigned __int16 a3);
BOOL __cdecl XTrapClient_SendData(struct CTcpLine *a1, char *buf, int len);
int __thiscall CTcpLine::OpenSocket(CTcpLine *__hidden this, char *cp, unsigned __int16); // idb
int __thiscall CTcpLine::Connect(CTcpLine *__hidden this, int); // idb
int __thiscall CTcpLine::Send(CTcpLine *__hidden this, char *buf, int len, int *, int); // idb
void __thiscall CTcpLine::CloseSocket(CTcpLine *__hidden this); // idb
unsigned int __cdecl GetLanguageInfo(); // idb
unsigned int __cdecl GetCpuInfo(); // idb
int __cdecl GetOsVersion();
void __cdecl MakeSendData(LPSTR lpString1, struct __XTRAP_LOG_INFO_XF_V1 *); // idb
int __cdecl Encryption(void *, int); // idb
void __cdecl SendMsgToMgrEx(char *Source, unsigned int, unsigned int, unsigned int); // idb
// void __usercall _L58401(int a1@<ebp>);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// void __cdecl operator delete(void *); idb
// int __stdcall WSACleanup();
// int __stdcall closesocket(SOCKET s);
// char *__stdcall inet_ntoa(struct in_addr in);
// u_short __stdcall htons(u_short hostshort);
// unsigned int __stdcall inet_addr(const char *cp);
// int __stdcall WSAGetLastError();
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// LANGID __stdcall GetSystemDefaultLangID();
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// int _sprintf(char *const Buffer, const char *const Format, ...);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// int __cdecl UniperEncFunc_Buf(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SHA1Digest_Buf(_DWORD, _DWORD, _DWORD); weak
// char *__cdecl _strncpy(char *Destination, const char *Source, size_t Count);
// int __stdcall lstrlenA(LPCSTR lpString);

//-------------------------------------------------------------------------
// Data declarations

void *CTcpLine::`vftable' = &CTcpLine::`vector deleting destructor'; // weak
_UNKNOWN _L58406; // weak
// extern _UNKNOWN g_GameInfo; weak
// extern _UNKNOWN g_MdlStartInfo; weak
// extern _UNKNOWN _except_list; weak


//----- (00000000) --------------------------------------------------------
CTcpLine *__thiscall CTcpLine::CTcpLine(CTcpLine *this)
{
  struct WSAData WSAData; // [esp+4h] [ebp-190h] BYREF

  *(_DWORD *)this = &CTcpLine::`vftable';
  if ( !WSAStartup(0x202u, &WSAData) && LOBYTE(WSAData.wVersion) == 2 )
    *((_DWORD *)this + 2) = -1;
  return this;
}
// 40: using guessed type void *CTcpLine::`vftable';

//----- (00000044) --------------------------------------------------------
CTcpLine *__thiscall CTcpLine::`scalar deleting destructor'(CTcpLine *this, char a2)
{
  CTcpLine::~CTcpLine(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00000064) --------------------------------------------------------
void __thiscall CTcpLine::~CTcpLine(CTcpLine *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 2);
  *(_DWORD *)this = &CTcpLine::`vftable';
  if ( v1 == -1 )
    closesocket(0xFFFFFFFF);
  WSACleanup();
}
// 40: using guessed type void *CTcpLine::`vftable';

//----- (00000084) --------------------------------------------------------
BOOL __cdecl XTrapClient_Connect(struct CTcpLine *a1, struct in_addr in, unsigned __int16 a3)
{
  char *v3; // eax
  BOOL result; // eax

  v3 = inet_ntoa(in);
  if ( CTcpLine::OpenSocket(a1, v3, a3) == 1 )
    result = CTcpLine::Connect(a1, 30) == 1;
  else
    result = 0;
  return result;
}

//----- (000000C4) --------------------------------------------------------
BOOL __cdecl XTrapClient_SendData(struct CTcpLine *a1, char *buf, int len)
{
  BOOL result; // eax
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = 0;
  if ( CTcpLine::Send(a1, buf, len, &v4, 0) == 1 )
    result = v4 == len;
  else
    result = 0;
  return result;
}

//----- (00000104) --------------------------------------------------------
int __thiscall CTcpLine::OpenSocket(CTcpLine *this, char *cp, unsigned __int16 hostshort)
{
  SOCKET v4; // eax
  char *v6; // eax

  v4 = socket(2, 1, 0);
  *((_DWORD *)this + 2) = v4;
  if ( v4 == -1 )
    return WSAGetLastError();
  v6 = cp;
  *((_WORD *)this + 6) = 2;
  if ( cp )
    v6 = (char *)inet_addr(cp);
  *((_DWORD *)this + 4) = v6;
  *((_WORD *)this + 7) = htons(hostshort);
  return 1;
}

//----- (00000164) --------------------------------------------------------
int __thiscall CTcpLine::Connect(CTcpLine *this, int a2)
{
  const struct sockaddr *v3; // ebx
  HANDLE v4; // ebp
  int v5; // esi
  SOCKET v7; // [esp-Ch] [ebp-34h]
  int i; // [esp+10h] [ebp-18h]
  int namelen; // [esp+14h] [ebp-14h] BYREF
  struct sockaddr name; // [esp+18h] [ebp-10h] BYREF

  v3 = (const struct sockaddr *)((char *)this + 12);
  if ( connect(*((_DWORD *)this + 2), (const struct sockaddr *)((char *)this + 12), 16) == -1 )
  {
    if ( WSAGetLastError() == 10060 )
      return 0;
    v4 = CreateEventA(0, 0, 0, 0);
    if ( !v4 )
      return 0;
    for ( i = 0; i < 10; ++i )
    {
      WaitForSingleObject(v4, 0xC8u);
      v5 = connect(*((_DWORD *)this + 2), v3, 16);
      if ( v5 != -1 )
        break;
      WSAGetLastError();
    }
    CloseHandle(v4);
    if ( v5 == -1 )
      return 0;
  }
  *(_DWORD *)&name.sa_family = 0;
  *(_DWORD *)&name.sa_data[2] = 0;
  *(_DWORD *)&name.sa_data[6] = 0;
  *(_DWORD *)&name.sa_data[10] = 0;
  v7 = *((_DWORD *)this + 2);
  namelen = 16;
  if ( getsockname(v7, &name, &namelen) == -1 || namelen != 16 )
    return 0;
  *((_DWORD *)this + 1) = *(_DWORD *)&name.sa_data[2];
  return 1;
}

//----- (00000254) --------------------------------------------------------
int __thiscall CTcpLine::Send(CTcpLine *this, char *buf, int len, int *a4, int a5)
{
  int v5; // eax

  v5 = send(*((_DWORD *)this + 2), buf, len, 0);
  if ( v5 == -1 )
    return 4;
  *a4 = v5;
  return 1;
}

//----- (00000294) --------------------------------------------------------
void __thiscall CTcpLine::CloseSocket(CTcpLine *this)
{
  closesocket(*((_DWORD *)this + 2));
}

//----- (000002A4) --------------------------------------------------------
unsigned int __cdecl GetLanguageInfo()
{
  return GetSystemDefaultLangID();
}

//----- (000002B4) --------------------------------------------------------
unsigned int __cdecl GetCpuInfo()
{
  LSTATUS v0; // esi
  unsigned int result; // eax
  HKEY phkResult; // [esp+0h] [ebp-10h] BYREF
  DWORD cbData; // [esp+4h] [ebp-Ch] BYREF
  BYTE Data[4]; // [esp+8h] [ebp-8h] BYREF
  DWORD Type; // [esp+Ch] [ebp-4h] BYREF

  phkResult = 0;
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, 0x20019u, &phkResult)
    || (*(_DWORD *)Data = 0,
        Type = 4,
        cbData = 4,
        v0 = RegQueryValueExA(phkResult, "~MHz", 0, &Type, Data, &cbData),
        RegCloseKey(phkResult),
        v0)
    || !cbData )
  {
    result = 0;
  }
  else
  {
    result = *(_DWORD *)Data;
  }
  return result;
}

//----- (0000037C) --------------------------------------------------------
int __cdecl GetOsVersion()
{
  BOOL (__stdcall *v0)(LPOSVERSIONINFOA); // edi
  int v1; // esi
  BOOL v2; // ebx
  int result; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-9Ch] BYREF
  __int16 v5; // [esp+A4h] [ebp-4h]
  char v6; // [esp+A6h] [ebp-2h]

  memset(&VersionInformation, 0, 0x9Cu);
  v0 = GetVersionExA;
  v1 = 0;
  VersionInformation.dwOSVersionInfoSize = 156;
  v2 = GetVersionExA(&VersionInformation);
  if ( v2 || (VersionInformation.dwOSVersionInfoSize = 148, (result = v0(&VersionInformation)) != 0) )
  {
    if ( VersionInformation.dwPlatformId == 1 )
    {
      if ( VersionInformation.dwMajorVersion == 4 )
      {
        switch ( VersionInformation.dwMinorVersion )
        {
          case 0u:
            return 2;
          case 0xAu:
            return (VersionInformation.szCSDVersion[1] == 65) + 3;
          case 0x5Au:
            v1 = 5;
            break;
        }
      }
    }
    else if ( VersionInformation.dwPlatformId == 2 )
    {
      switch ( VersionInformation.dwMajorVersion )
      {
        case 3u:
          if ( VersionInformation.dwMinorVersion == 51 )
            v1 = 6;
          break;
        case 4u:
          if ( !VersionInformation.dwMinorVersion )
            v1 = 7;
          break;
        case 5u:
          if ( VersionInformation.dwMinorVersion )
          {
            if ( VersionInformation.dwMinorVersion == 1 )
            {
              v1 = 9;
            }
            else if ( VersionInformation.dwMinorVersion == 2 )
            {
              v1 = 10;
            }
          }
          else
          {
            v1 = 8;
          }
          break;
      }
      if ( v2 )
      {
        switch ( v1 )
        {
          case 8:
            switch ( v6 )
            {
              case 1:
                return 24;
              case 3:
                return 40;
              case 2:
                return 56;
            }
            break;
          case 9:
            if ( v6 == 1 )
              return (v5 & 0x200) != 0 ? 25 : 41;
            break;
          case 10:
            switch ( v6 )
            {
              case 1:
                return 57;
              case 3:
                return 42;
              case 2:
                return 58;
            }
            break;
        }
      }
    }
    result = v1;
  }
  return result;
}

//----- (0000056C) --------------------------------------------------------
void __cdecl MakeSendData(LPSTR lpString1, struct __XTRAP_LOG_INFO_XF_V1 *a2)
{
  unsigned int v2; // ecx
  int v3; // eax
  void (*v4)(char *const, const char *const, ...); // ebx
  unsigned int v5; // [esp+10h] [ebp-1FCh]
  unsigned int v6; // [esp+14h] [ebp-1F8h]
  char Buffer; // [esp+18h] [ebp-1F4h] BYREF
  char v8[496]; // [esp+19h] [ebp-1F3h] BYREF
  __int16 v9; // [esp+209h] [ebp-3h]
  char v10; // [esp+20Bh] [ebp-1h]

  Buffer = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v2 = *((_DWORD *)a2 + 1);
  v10 = 0;
  v5 = *((_DWORD *)a2 + 69);
  v6 = v2;
  lstrcpyA(lpString1, "123456789012");
  v3 = *(_DWORD *)a2;
  v4 = (void (*)(char *const, const char *const, ...))_sprintf;
  if ( *(_DWORD *)a2 == 1 )
  {
    _sprintf(&Buffer, "%u||%u||%u||%u||%u||", 1, 0, 1, 0, 0);
  }
  else
  {
    switch ( v3 )
    {
      case 2:
        _sprintf(&Buffer, "%u||%u||%u||%u||%u||", 0, 1, 0, 0, 0);
        break;
      case 3:
        _sprintf(&Buffer, "%u||%u||%u||%u||%u||", 0, 0, 1, 0, 0);
        break;
      case 4:
        _sprintf(&Buffer, "%u||%u||%u||%u||%u||", 0, 0, 0, 1, 0);
        break;
      case 5:
        _sprintf(&Buffer, "%u||%u||%u||%u||%u||", 0, 0, 0, 0, 1);
        break;
    }
  }
  strcat(lpString1, &Buffer);
  v4(&Buffer, "%.3x||%.3x||%.2x||", (v6 >> 12) & 0xFFF, v6 & 0xFFF, HIBYTE(v6));
  strcat(lpString1, &Buffer);
  v4(
    &Buffer,
    "%s||%s||%s||%s||%.8x||",
    (const char *)a2 + 8,
    (const char *)a2 + 72,
    (const char *)a2 + 136,
    (const char *)a2 + 200,
    *((_DWORD *)a2 + 66));
  strcat(lpString1, &Buffer);
  v4(
    &Buffer,
    "%.2x||%.8x||%u.%u.%u.%u||%04x||",
    *((_DWORD *)a2 + 67),
    *((_DWORD *)a2 + 68),
    (unsigned __int8)v5,
    BYTE1(v5),
    BYTE2(v5),
    HIBYTE(v5),
    *((_DWORD *)a2 + 70));
  strcat(lpString1, &Buffer);
  v4(
    &Buffer,
    "%.8x||%.8x||%.8x||%.4x||",
    *((_DWORD *)a2 + 71),
    *((_DWORD *)a2 + 72),
    *((_DWORD *)a2 + 74),
    *((_DWORD *)a2 + 75));
  strcat(lpString1, &Buffer);
  v4(
    &Buffer,
    "%.8x||%.8x||%.8x||%.8x||%.8x||",
    *((_DWORD *)a2 + 77),
    *((_DWORD *)a2 + 76),
    *((_DWORD *)a2 + 78),
    *((_DWORD *)a2 + 79),
    *((_DWORD *)a2 + 80));
  strcat(lpString1, &Buffer);
  v4(
    &Buffer,
    "%.8x||%s||%.8x||%.8x||%.8x",
    *((_DWORD *)a2 + 73),
    (const char *)a2 + 336,
    *((_DWORD *)a2 + 81),
    *((_DWORD *)a2 + 82),
    *((_DWORD *)a2 + 83));
  strcat(lpString1, &Buffer);
}

//----- (00000988) --------------------------------------------------------
int __cdecl Encryption(void *a1, int a2)
{
  int v2; // ebx
  int result; // eax
  void (*v4)(char *const, const char *const, ...); // ebp
  char Buffer; // [esp+8h] [ebp-54h] BYREF
  int v6; // [esp+9h] [ebp-53h]
  int v7; // [esp+Dh] [ebp-4Fh]
  int v8; // [esp+11h] [ebp-4Bh]
  __int16 v9; // [esp+15h] [ebp-47h]
  char v10; // [esp+17h] [ebp-45h]
  char v11; // [esp+18h] [ebp-44h] BYREF
  char v12[28]; // [esp+19h] [ebp-43h] BYREF
  __int16 v13; // [esp+35h] [ebp-27h]
  char v14; // [esp+37h] [ebp-25h]
  char v15[33]; // [esp+38h] [ebp-24h] BYREF

  v2 = 0;
  v11 = 0;
  memset(v12, 0, sizeof(v12));
  v13 = 0;
  v14 = 0;
  result = SHA1Digest_Buf(a1, a2 - 32, &v11);
  if ( result )
  {
    v6 = 0;
    v7 = 0;
    v4 = (void (*)(char *const, const char *const, ...))_sprintf;
    v8 = 0;
    v9 = 0;
    v15[0] = 0;
    Buffer = 0;
    v10 = 0;
    memset(&v15[1], 0, 0x20u);
    do
    {
      v4(&Buffer, "%.2x", (unsigned __int8)*(&v11 + v2));
      strcat(v15, &Buffer);
      ++v2;
    }
    while ( v2 < 16 );
    qmemcpy((char *)a1 + a2 - 32, v15, 0x20u);
    result = UniperEncFunc_Buf(a1, a2, "891882f7d4235da", strlen("891882f7d4235da")) != 0;
  }
  return result;
}
// E10: using guessed type int __cdecl UniperEncFunc_Buf(_DWORD, _DWORD, _DWORD, _DWORD);
// E14: using guessed type int __cdecl SHA1Digest_Buf(_DWORD, _DWORD, _DWORD);

//----- (00000AA0) --------------------------------------------------------
void __cdecl SendMsgToMgrEx(char *Source, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int (__stdcall *v4)(LPCSTR); // edi
  unsigned int v5; // eax
  int v6; // ecx
  void (__cdecl *v7)(char *, const char *, size_t); // esi
  unsigned int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  _BYTE Buffer[12]; // [esp+0h] [ebp-64Ch] BYREF
  char v16[4]; // [esp+Ch] [ebp-640h] BYREF
  int v17; // [esp+10h] [ebp-63Ch]
  int v18[2]; // [esp+28h] [ebp-624h] BYREF
  char Destination[64]; // [esp+30h] [ebp-61Ch] BYREF
  char v20[64]; // [esp+70h] [ebp-5DCh] BYREF
  char v21[64]; // [esp+B0h] [ebp-59Ch] BYREF
  char v22[64]; // [esp+F0h] [ebp-55Ch] BYREF
  int v23; // [esp+130h] [ebp-51Ch]
  int v24; // [esp+134h] [ebp-518h]
  unsigned int v25; // [esp+138h] [ebp-514h]
  int v26; // [esp+13Ch] [ebp-510h]
  unsigned int v27; // [esp+140h] [ebp-50Ch]
  int v28; // [esp+144h] [ebp-508h]
  unsigned int v29; // [esp+148h] [ebp-504h]
  int v30; // [esp+14Ch] [ebp-500h]
  unsigned int v31; // [esp+150h] [ebp-4FCh]
  unsigned int v32; // [esp+154h] [ebp-4F8h]
  int v33; // [esp+158h] [ebp-4F4h]
  int v34; // [esp+15Ch] [ebp-4F0h]
  int v35; // [esp+160h] [ebp-4ECh]
  int v36; // [esp+164h] [ebp-4E8h]
  int v37; // [esp+168h] [ebp-4E4h]
  int v38; // [esp+16Ch] [ebp-4E0h]
  int v39; // [esp+170h] [ebp-4DCh]
  int v40; // [esp+174h] [ebp-4D8h]
  char v41[200]; // [esp+178h] [ebp-4D4h] BYREF
  CHAR String[4]; // [esp+240h] [ebp-40Ch] BYREF
  int v43; // [esp+244h] [ebp-408h]
  int v44; // [esp+248h] [ebp-404h]
  __int16 v45; // [esp+63Dh] [ebp-Fh]
  char v46; // [esp+63Fh] [ebp-Dh]
  unsigned int v47[2]; // [esp+640h] [ebp-Ch] BYREF
  int v48; // [esp+648h] [ebp-4h]

  v48 = -1;
  v47[1] = (unsigned int)&_L58406;
  v47[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v47);
  CTcpLine::CTcpLine((CTcpLine *)v16);
  String[0] = 0;
  memset(&String[1], 0, 0x3FCu);
  v45 = 0;
  v46 = 0;
  v4 = lstrlenA;
  v48 = 0;
  if ( lstrlenA((LPCSTR)&g_MdlStartInfo + 1344)
    && *((_WORD *)&g_MdlStartInfo + 802)
    && (v5 = inet_addr((const char *)&g_MdlStartInfo + 1344),
        XTrapClient_Connect((struct CTcpLine *)v16, (struct in_addr)v5, *((_DWORD *)&g_MdlStartInfo + 401))) )
  {
    v6 = *((_DWORD *)&g_MdlStartInfo + 9);
    v7 = (void (__cdecl *)(char *, const char *, size_t))_strncpy;
    v18[0] = 1;
    v18[1] = v6;
    _strncpy(Destination, (const char *)&g_GameInfo + 96, 0x3Eu);
    v7(v20, (const char *)&g_GameInfo + 164, 0x3Eu);
    v7(v21, (const char *)&g_GameInfo + 228, 0x3Eu);
    v7(v22, (const char *)&g_GameInfo + 292, 0x3Eu);
    v23 = *((_DWORD *)&g_GameInfo + 40);
    v24 = GetOsVersion();
    v25 = GetCpuInfo();
    v26 = v17;
    v8 = GetLanguageInfo();
    v29 = a2;
    v9 = *((_DWORD *)&g_MdlStartInfo + 8);
    v27 = v8;
    v32 = a4;
    v10 = *((_DWORD *)&g_MdlStartInfo + 419);
    v33 = v9;
    v11 = *((_DWORD *)&g_MdlStartInfo + 421);
    v31 = a3;
    v12 = *((_DWORD *)&g_MdlStartInfo + 11);
    v38 = v10;
    v40 = v11;
    v35 = v12;
    v13 = *((_DWORD *)&g_MdlStartInfo + 420);
    v28 = 3;
    v30 = 0;
    v34 = -1526722202;
    v36 = -452984832;
    v37 = 0;
    v39 = v13;
    v7(v41, Source, 0xC6u);
    MakeSendData(String, (struct __XTRAP_LOG_INFO_XF_V1 *)v18);
    *(_DWORD *)&Buffer[1] = 0;
    *(_DWORD *)&Buffer[5] = 0;
    *(_WORD *)&Buffer[9] = 0;
    Buffer[0] = 0;
    Buffer[11] = 0;
    _sprintf(Buffer, "%s", "XL_XF_V1");
    v14 = v4(String);
    *(_DWORD *)String = *(_DWORD *)Buffer;
    *(_DWORD *)&Buffer[8] = v14 + 32;
    v43 = *(_DWORD *)&Buffer[4];
    v44 = v14 + 32;
    Encryption(String, v14 + 32);
    XTrapClient_SendData((struct CTcpLine *)v16, String, *(int *)&Buffer[8]);
    CTcpLine::CloseSocket((CTcpLine *)v16);
    CTcpLine::~CTcpLine((CTcpLine *)v16);
    __writefsdword((unsigned int)&_except_list, v47[0]);
  }
  else
  {
    CTcpLine::~CTcpLine((CTcpLine *)v16);
    __writefsdword((unsigned int)&_except_list, v47[0]);
  }
}

//----- (00000D60) --------------------------------------------------------
void __usercall _L58401(int a1@<ebp>)
{
  CTcpLine::~CTcpLine((CTcpLine *)(a1 - 1600));
}

// nfuncs=45 queued=16 decompiled=16 lumina nreq=0 worse=0 better=0
// ALL OK, 16 function(s) have been successfully decompiled
