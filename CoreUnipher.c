/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __cdecl set_subkey(unsigned int *, unsigned int *); // idb
void __cdecl encryption(unsigned int *, unsigned int *, unsigned int *); // idb
void __cdecl decryption(unsigned int *, unsigned int *, unsigned int *); // idb
void __cdecl BufEncryptionECB(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
void __cdecl BufDecryptionECB(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
void __cdecl BufEncryptionCBC(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
void __cdecl BufDecryptionCBC(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
void __cdecl BufEncryptionCFB(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
void __cdecl BufDecryptionCFB(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
void __cdecl BufEncryptionOFB(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
void __cdecl BufDecryptionOFB(unsigned __int8 *, int, unsigned __int8 *, unsigned int *); // idb
int __cdecl UniperEncFunc(unsigned __int8 *, size_t Size, unsigned __int8 *, int, int); // idb
int __cdecl UniperDecFunc(unsigned __int8 *, size_t Size, unsigned __int8 *, int, int); // idb
// void __cdecl operator delete(void *); idb
// void *__cdecl _malloc(size_t Size);

//-------------------------------------------------------------------------
// Data declarations

int S0[33] =
{
  20,
  77,
  182,
  35,
  69,
  242,
  129,
  217,
  178,
  164,
  103,
  132,
  208,
  32,
  252,
  189,
  71,
  115,
  76,
  220,
  163,
  59,
  92,
  243,
  118,
  140,
  14,
  143,
  96,
  100,
  206,
  187,
  179
}; // idb
void *S1 = &unk_84; // weak
int SS0[256] =
{
  340802600,
  1294587802,
  -1226651791,
  596403526,
  1158270858,
  -219214855,
  -2126602721,
  -649890129,
  -1292711047,
  -1532300971,
  1736550862,
  -2077585131,
  -798528067,
  545284160,
  -53011995,
  -1110517145,
  1191299470,
  1943115238,
  1278071960,
  -598247003,
  -1548289957,
  1005342070,
  1550705848,
  -202700549,
  1992661740,
  -1945466619,
  238555676,
  -1895396349,
  1620943040,
  1687006408,
  -836808831,
  -1143549845,
  -1275672453,
  1910084578,
  -1449204145,
  2009176558,
  954222704,
  -441240873,
  1893568736,
  -820294525,
  -1054646625,
  -1242643849,
  -1928427001,
  -1754880973,
  817909856,
  -1771919567,
  -377280817,
  17040130,
  630484810,
  613444680,
  1484646576,
  -1037083751,
  425995058,
  -1482230701,
  -679779149,
  391919918,
  783839836,
  1228528530,
  749761624,
  -888455029,
  2046397426,
  -1622754269,
  -854373753,
  -87092247,
  -922532209,
  1311101596,
  -1466243763,
  -1787911625,
  -1003007595,
  -291557439,
  -1416175541,
  1839839194,
  34080260,
  2112456698,
  -491832359,
  -730373707,
  647522892,
  -1433214135,
  -134544141,
  -1655784921,
  -253293059,
  272642080,
  -904969335,
  68160520,
  -696293455,
  -1383142841,
  -615812949,
  1637458882,
  102238732,
  357842730,
  1430912938,
  -747935557,
  -457756203,
  766801754,
  -1871008451,
  -1912434943,
  -2110612711,
  -1127556763,
  204477464,
  937187694,
  851990116,
  903110506,
  2145485310,
  85200650,
  -1672824539,
  1567221690,
  -1020569445,
  1926600420,
  -70577941,
  681605200,
  -1688817621,
  -1325740675,
  153361170,
  -325637691,
  -1259683467,
  511189564,
  136321040,
  1125238150,
  -168623369,
  1790295764,
  -1400182459,
  1397880230,
  -547652445,
  -2143642339,
  -151058447,
  -1639792863,
  1670489542,
  -782012737,
  -185138699,
  1463941550,
  971262834,
  1073496446,
  1245044372,
  -952413037,
  -632327255,
  -1721846225,
  2095940856,
  1534193078,
  1773779922,
  698645330,
  -986492265,
  -1820940229,
  -1499269295,
  2062913268,
  528228670,
  -713858377,
  -1367150783,
  -1209613197,
  1872867806,
  306722340,
  1959632104,
  -1515261353,
  221517594,
  1056457340,
  1261559190,
  255594782,
  -343203637,
  -1077486493,
  -564166751,
  -764449863,
  1720036044,
  1039419258,
  374880812,
  -2027514861,
  2079428086,
  -18931743,
  477111352,
  886070376,
  1976147946,
  460074294,
  -968927343,
  -1994488305,
  -36496665,
  -423675951,
  -1598358179,
  187440406,
  494151482,
  -2093574117,
  -1705856215,
  562324290,
  -1160588439,
  -393796147,
  -104655121,
  0,
  1823323352,
  1092207490,
  -2044553455,
  -666405459,
  1447426732,
  920148588,
  1501162418,
  1381365412,
  1600250302,
  -2060545513,
  1075691648,
  579364420,
  408954928,
  1806810582,
  -1961459701,
  1327616414,
  119277838,
  -939047539,
  -1978498295,
  1856352988,
  -1350112189,
  323761446,
  -1837978823,
  1108723332,
  1348333728,
  -1738885843,
  -1094525087,
  -1853968833,
  -236777729,
  1022379128,
  664561998,
  2128970492,
  -309122361,
  715685460,
  170401300,
  869029222,
  -581731673,
  1414397096,
  1174784652,
  800878942,
  -1804951243,
  1653974724,
  1757264080,
  1517678260,
  1141755016,
  -1071161955,
  289682210,
  51119366,
  443035188,
  -1193618067,
  -1308701057,
  -525910563,
  -359717943,
  -1565328551,
  732724566,
  2029881584,
  1212012688,
  834949986,
  -1176578449,
  -475318053,
  -2417437,
  -275043133,
  1583735484,
  -407161645,
  1703522250,
  -870889083,
  1364849570,
  -509395233,
  -1581318561,
  988302964,
  -121170451,
  -2011527923
}; // idb
int SS1[256] =
{
  360983185,
  2075391688,
  -1033791069,
  -1041326289,
  739661882,
  -1076796562,
  369830941,
  1840831189,
  874145838,
  -1336377880,
  -1134664222,
  -168495359,
  798580406,
  26083983,
  -873755872,
  1436855025,
  -101519605,
  -302463211,
  1849154649,
  -1907949111,
  -2042424891,
  831939239,
  -907374813,
  -1437251073,
  235346953,
  -1571726861,
  806903848,
  1647428691,
  -1975186993,
  2084501570,
  -58792574,
  1983638605,
  564019903,
  941387812,
  67241990,
  461584024,
  -235471097,
  773282873,
  764959413,
  -369438957,
  -1648351395,
  33620995,
  -1210748062,
  -1840694821,
  -1504488971,
  -2016603318,
  -1882651834,
  1369875191,
  -495855213,
  -134876414,
  1066499758,
  1570814717,
  -1579262081,
  1882775624,
  427963035,
  -706431183,
  1974790849,
  -1916270779,
  -1605345808,
  528563870,
  1874452182,
  -974350551,
  1008629794,
  -394998372,
  -899315281,
  -1143772312,
  294003351,
  1202556650,
  2118122561,
  -1177391253,
  -773406921,
  1042250785,
  -1849278633,
  -1715327141,
  403451924,
  -639455429,
  571556915,
  -1000172122,
  1546565746,
  268967960,
  1781912671,
  -469771492,
  168104975,
  -1302758933,
  201725962,
  -226887285,
  -1201902108,
  -1614732450,
  1740492506,
  0,
  -1949627584,
  -268844266,
  999519912,
  -1244367007,
  -1538107914,
  2008411842,
  -697585219,
  1075871840,
  -436414695,
  -1874313768,
  1941432004,
  1168935657,
  1277597802,
  -1478667398,
  93063817,
  -596728398,
  1210355820,
  -126030460,
  -34543859,
  1445702781,
  865560228,
  -503390433,
  100862981,
  1815533658,
  394604178,
  -1748683950,
  327624340,
  260644486,
  -1983246525,
  134483980,
  -402795750,
  -1470870020,
  1311218793,
  59704972,
  1235915491,
  -798442056,
  1243976815,
  975008807,
  -1672600110,
  1580186737,
  -462236266,
  -940731606,
  1302895333,
  -1101045279,
  -1378334859,
  -428617323,
  -1941568054,
  -924914,
  -932934228,
  1135576812,
  1807472336,
  1681049686,
  1706871513,
  -1344715914,
  -2109662781,
  -865696342,
  840524843,
  -672812238,
  -335820016,
  907766829,
  -605836488,
  -1512286343,
  -260506232,
  -764823109,
  1479323764,
  630999737,
  1512944759,
  -2143281728,
  1537455864,
  -92411513,
  -1445310605,
  302588955,
  -1067410016,
  898919073,
  -1168283161,
  504314897,
  1109492835,
  1344839800,
  -832077399,
  1950017614,
  -1411691664,
  1101955823,
  -563109455,
  -294141543,
  1176734821,
  -739787980,
  1470476018,
  -1007707348,
  638798901,
  336209950,
  1673512668,
  -1706219049,
  672419900,
  1143113830,
  731600560,
  -630347337,
  537935920,
  2017259588,
  1269536480,
  -2050222263,
  706040895,
  -1110415507,
  160043651,
  -529474160,
  -806780122,
  -731204162,
  -1269139986,
  494942877,
  -1807075874,
  -1370013191,
  1916396619,
  -538860738,
  -2117198001,
  -25173631,
  664620730,
  597640892,
  1907811015,
  437072919,
  1748291676,
  -201852156,
  -1782302895,
  -1311342745,
  2142371534,
  126684810,
  932540066,
  1503834875,
  2041770699,
  -2083579060,
  -966553179,
  1714670677,
  -1681708200,
  -1638981167,
  -327760486,
  1613807696,
  1378460795,
  1604435710,
  -572479683,
  -361379425,
  965898923,
  -2008805940,
  -159649395,
  -2076043834,
  1639891679,
  -1235521043,
  -193268338,
  -840399067,
  1336516326,
  -1815659692,
  -1773456931,
  2050880583,
  -1739837996,
  -1277723804,
  -1545643140,
  227023493,
  193664640,
  -1403632134,
  470693906,
  -67900664,
  1773851347,
  697979571,
  2108750541,
  -663966284,
  1403496180,
  605177910,
  1032878765,
  1412081790
}; // idb
int SS2[256] =
{
  1009259600,
  -677753559,
  -948848926,
  1699095436,
  -813021943,
  200930031,
  -1642102466,
  1991235907,
  -881216782,
  -246045526,
  -1446090879,
  -1860860886,
  1841156199,
  1614815360,
  434502871,
  -630735410,
  -913422591,
  -1780059183,
  -728216531,
  2040912983,
  -128212042,
  1299594220,
  -457679763,
  150729707,
  -1695779131,
  -1996125174,
  303828536,
  -1945923834,
  -1598005091,
  -1396153203,
  1333906975,
  -798245930,
  -931417098,
  -1813876263,
  -430986850,
  -1712425023,
  1215314144,
  853009843,
  -1864339235,
  1283706651,
  1587527971,
  -1032342034,
  -1979216626,
  -1540122778,
  1348481216,
  -1489922462,
  651159939,
  50462980,
  1867130260,
  1816667280,
  -391096195,
  1536803375,
  724703588,
  -195844186,
  1689507707,
  959321948,
  1918643896,
  -611169991,
  1951935664,
  1082903307,
  -1947043335,
  -1138516154,
  1250413843,
  334101199,
  1183828227,
  -761508315,
  -447895398,
  -1573415570,
  1368769591,
  801238687,
  -531911786,
  -1210421847,
  100925960,
  -2013626903,
  1004135087,
  1639306359,
  1783375512,
  -481711470,
  83097595,
  -1171808946,
  234746087,
  807407680,
  1133103631,
  201851920,
  1739708031,
  -364401266,
  1890310987,
  -1547542119,
  168560152,
  1059722580,
  -5614263,
  1757139819,
  836101303,
  2002398644,
  -1388474246,
  -1895723518,
  -1692827086,
  -647643958,
  337120304,
  1500395484,
  1449407176,
  1600796116,
  -2114027551,
  252314900,
  -1188717494,
  -407216791,
  1486603051,
  -1763413291,
  283900875,
  2018519200,
  -1339319466,
  -847400710,
  454166820,
  700837015,
  -1049250582,
  574365304,
  403703840,
  -981056751,
  49804787,
  -1093375307,
  -381309814,
  -173649071,
  2091114331,
  -1659011014,
  133297919,
  -1088315838,
  -1513725039,
  1858064739,
  32896247,
  -106014911,
  1265777124,
  1098792956,
  -560707019,
  1418970939,
  1940511311,
  -1238394530,
  -2064089875,
  -306816143,
  -1143838279,
  2068982180,
  1385678131,
  -1472490634,
  -145643870,
  -1896580363,
  557719420,
  1656214899,
  -280908158,
  -999049242,
  -1310822495,
  908333640,
  -1662487347,
  -229136978,
  387583284,
  1115438840,
  -577352911,
  287182652,
  550235019,
  -597442618,
  2141314655,
  1807340143,
  -1429444987,
  1199193588,
  975967832,
  -1810659546,
  -1913226255,
  534904543,
  607657072,
  1550333136,
  -1612024375,
  758520684,
  1469171263,
  -2045802210,
  451411411,
  936502975,
  -44195654,
  487983916,
  658120052,
  -1743027402,
  -1289119150,
  1665278340,
  -748045614,
  634251399,
  384825795,
  0,
  -1260884819,
  -1014873831,
  -1760459230,
  1974327367,
  -89369019,
  1517041368,
  -340633223,
  -157003179,
  -507617439,
  -1843952338,
  -1065336803,
  1715741320,
  674240608,
  -1110021199,
  -2146727146,
  -778154207,
  151914268,
  1166919687,
  -2096526830,
  -1294176603,
  -331108474,
  891687756,
  -1422290318,
  -964410859,
  -257929123,
  -1255303078,
  -547242302,
  -1371565698,
  251654627,
  1148730608,
  1766729628,
  -2097381659,
  717745555,
  2119445160,
  504629800,
  1432761292,
  2057821523,
  -56077235,
  -896776699,
  1901998012,
  -1590324118,
  -1497079147,
  -1194301251,
  -290170251,
  -863484915,
  1570619431,
  857870660,
  84280076,
  775166568,
  -714229542,
  -830492162,
  1037951143,
  600435343,
  -78011726,
  2102799276,
  -1997506307,
  -661632963,
  1398944196,
  -697320994,
  953934763,
  484704219,
  751038363,
  -490971547,
  886302651,
  -1345690231,
  1233505303,
  -207466151,
  1054859683,
  -27287106,
  1316240104,
  367917255,
  -2062710758
}; // idb
int SS3[256] =
{
  714151300,
  -154633293,
  -1717321119,
  -1624260114,
  1480207382,
  1668202449,
  740103691,
  -623546952,
  1747858458,
  2112401496,
  1709358174,
  -150866444,
  1588998041,
  42926478,
  -1960784917,
  -1427024476,
  -284427790,
  -954864136,
  -598118857,
  29986375,
  298157635,
  1655124374,
  -1893479958,
  1241492053,
  470355463,
  1509139025,
  1613246488,
  -1001168335,
  164596293,
  -129860546,
  -444400514,
  -330467781,
  1119822238,
  1881421852,
  134611970,
  915938179,
  -16256522,
  1547251223,
  1521823128,
  -820778502,
  660446656,
  67305985,
  1935849429,
  970691145,
  1375053395,
  323651533,
  54955977,
  -1560850010,
  -644619663,
  -217909259,
  2125348753,
  -1157800544,
  1602200030,
  -532123592,
  849025410,
  -1221470748,
  -356420172,
  121998792,
  1576050768,
  1050550145,
  -556372039,
  -1758870036,
  2015509534,
  -845354892,
  -1984968091,
  1802025939,
  580325766,
  -1897248851,
  -62816705,
  1869330898,
  -1086860826,
  2082553375,
  1062703558,
  794532290,
  806623244,
  -1355032094,
  1144201745,
  -1784232862,
  -1200464850,
  538447880,
  -731944395,
  -618863617,
  336529925,
  2045489753,
  403311622,
  -108268935,
  1843705948,
  593403841,
  -824547395,
  0,
  188779467,
  -1021906951,
  1990736787,
  2002892244,
  1442227282,
  -289245259,
  -1312958869,
  -2141175776,
  -686168580,
  1037602888,
  -423332937,
  -1964423764,
  -1737864154,
  1400547293,
  176752012,
  -1515004818,
  -1871951836,
  -310052740,
  -418513424,
  -1401072085,
  1722037143,
  -551558658,
  201655811,
  -665162698,
  781326213,
  861050821,
  647238535,
  512102281,
  256084426,
  269223940,
  -753211395,
  1308403796,
  -1670820313,
  109839247,
  -1830598230,
  -1111961496,
  -1804645851,
  1948727837,
  634559566,
  -1133421009,
  -711531406,
  -1825912851,
  -1696248408,
  1642184287,
  1198894552,
  -778705293,
  97160262,
  -485556239,
  -1918056348,
  -2031336529,
  -690984005,
  -933862350,
  -891722308,
  1131851737,
  432243265,
  -2052404122,
  1680552473,
  -1288513563,
  -888083461,
  1814902299,
  -1422337053,
  1467590108,
  -41357192,
  -1178873239,
  -1334552532,
  1253647772,
  -1267246547,
  499155008,
  -1225237597,
  -376964483,
  1332980186,
  605753865,
  -1650409376,
  1788949908,
  1776794205,
  1007754767,
  -2073869791,
  -1602727896,
  -2119578009,
  -397511622,
  1265675227,
  -2098249298,
  -1582178705,
  -1046876553,
  -1939519965,
  -1154165785,
  -1359849563,
  -1691565073,
  1278551571,
  673059850,
  -958635073,
  701995597,
  1346119700,
  -2006563806,
  1454386075,
  -1447568787,
  1076895760,
  -263948228,
  -1763685461,
  390694348,
  1413425685,
  1735245264,
  310577546,
  -577707920,
  -2094608407,
  -1245784982,
  1978578010,
  983375232,
  903779402,
  1106882135,
  -464817607,
  -1556160543,
  525304270,
  -511574401,
  1320822685,
  1186735007,
  -490245706,
  873929229,
  -799250380,
  -83561481,
  928093636,
  2137502166,
  -20021327,
  243926925,
  1856124821,
  -1292150366,
  -221546062,
  457999311,
  -1851406749,
  -866818509,
  727227331,
  567385679,
  -979702666,
  -1068474320,
  -1535421911,
  -1090625631,
  -1489117728,
  -912266635,
  1923824018,
  231508036,
  -242354565,
  365331522,
  -1025547842,
  1911404123,
  -175180678,
  -2027565592,
  -1629073495,
  995398599,
  836605515,
  -196642243,
  768907340,
  2070197207,
  1534895071,
  444927368,
  377490315,
  1174056022,
  940710926,
  -351732749,
  -757896774,
  1387473306,
  -87196240,
  -1380657044,
  -1493937241,
  1211507730,
  2058173840,
  -1468115926
}; // idb


//----- (00001800) --------------------------------------------------------
void __cdecl set_subkey(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2; // ebp
  unsigned int v3; // ecx
  unsigned int v4; // eax
  int v5; // esi
  int v6; // ebp
  unsigned int v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // edi
  unsigned int v12; // ebp
  int i; // ecx
  bool v14; // zf
  int j; // ecx
  int v17; // edx
  unsigned int v18; // [esp+10h] [ebp-154h]
  int v19; // [esp+18h] [ebp-14Ch]
  int v20; // [esp+18h] [ebp-14Ch]
  char *v21; // [esp+1Ch] [ebp-148h]
  int v22; // [esp+20h] [ebp-144h]
  int v23; // [esp+24h] [ebp-140h]
  int v24; // [esp+28h] [ebp-13Ch]
  int v25; // [esp+2Ch] [ebp-138h]
  int v26; // [esp+30h] [ebp-134h]
  int v27; // [esp+34h] [ebp-130h]
  int v28; // [esp+38h] [ebp-12Ch]
  int v29; // [esp+3Ch] [ebp-128h]
  int v30; // [esp+40h] [ebp-124h]
  int v31; // [esp+44h] [ebp-120h]
  char v32; // [esp+48h] [ebp-11Ch] BYREF

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v27 = -1209970334;
  v28 = -1964168598;
  v29 = -1083090816;
  v30 = -1661668409;
  v23 = 608135816;
  v24 = -2052912941;
  v25 = 320440878;
  v26 = 57701188;
  v21 = &v32;
  v22 = 18;
  while ( 1 )
  {
    v6 = v27 ^ v2;
    v7 = (v28 + v3) ^ (v5 + v30);
    v8 = v6 + (v29 ^ v4);
    v18 = SS3[(unsigned __int8)v7] ^ SS0[HIBYTE(v7)] ^ SS2[BYTE1(v7)] ^ SS1[BYTE2(v7)];
    v9 = (unsigned int)*(&S1 + (unsigned __int8)v18) ^ ((S0[BYTE1(v18)] ^ (((S0[HIBYTE(v18)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v18))) << 8)) << 8);
    v10 = SS3[(unsigned __int8)v8] ^ SS0[HIBYTE(v8)] ^ SS2[BYTE1(v8)] ^ SS1[BYTE2(v8)];
    v11 = (unsigned int)*(&S1 + (unsigned __int8)v10) ^ ((S0[BYTE1(v10)] ^ (((S0[HIBYTE(v10)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v10))) << 8)) << 8);
    v19 = (v11 + v9) ^ (v28 + v3);
    v12 = v11 + 2 * v9 + v6;
    v5 = v23 ^ v12;
    *((_DWORD *)v21 - 1) = v23 ^ v12;
    v4 = v26 + __ROL4__(v7, v12 & 0x1F);
    v2 = v19 + v24;
    *(_DWORD *)v21 = v19 + v24;
    v20 = __ROL4__(v8, v19 & 0x1F) ^ v25;
    *((_DWORD *)v21 + 1) = v20;
    *((_DWORD *)v21 + 2) = v4;
    for ( i = 0; i < 16; i += 4 )
    {
      *(int *)((char *)&v27 + i) = *(int *)((char *)&v23 + i);
      *(int *)((char *)&v23 + i) = *(int *)((char *)&v31 + i);
    }
    v14 = v22 == 1;
    v21 += 16;
    --v22;
    if ( v14 )
      break;
    v3 = v20;
  }
  for ( j = 0; j < 792; j += 11 )
  {
    v17 = j % 72;
    *a2++ = *(&v31 + v17);
  }
}
// 400: using guessed type void *S1;

//----- (00001A80) --------------------------------------------------------
void __cdecl encryption(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v5; // ebp
  unsigned int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // edi
  unsigned int v10; // eax
  int v11; // ecx
  unsigned int v12; // edi
  unsigned int v13; // edi
  unsigned int v14; // edi
  int v15; // ebx
  unsigned int v16; // edi
  int v17; // edx
  unsigned int v18; // edi
  int v19; // ebp
  unsigned int v20; // eax
  unsigned int v21; // edi
  unsigned int v22; // eax
  unsigned int v23; // ebp
  int v24; // edi
  int v25; // edx
  int v26; // eax
  unsigned int v27; // ebp
  unsigned int v28; // edi
  int v29; // ebx
  unsigned int v30; // eax
  unsigned int v31; // edi
  int v32; // ebp
  unsigned int v33; // ebx
  int v34; // edi
  unsigned int v35; // eax
  unsigned int v36; // edx
  unsigned int v37; // ebx
  unsigned int v38; // edi
  unsigned int v39; // edx
  int v40; // eax
  int v41; // edx
  unsigned int v42; // edi
  unsigned int v43; // ebx
  unsigned int v44; // ebp
  unsigned int v45; // edx
  unsigned int v46; // ebx
  int v47; // edi
  unsigned int v48; // ebp
  int v49; // ebx
  unsigned int v50; // edx
  unsigned int v51; // eax
  unsigned int v52; // ebp
  unsigned int v53; // ebx
  unsigned int v54; // eax
  int v55; // edx
  unsigned int v56; // ebp
  int v57; // eax
  unsigned int v58; // ebx
  unsigned int v59; // edi
  unsigned int v60; // ebp
  unsigned int v61; // eax
  unsigned int v62; // edi
  int v63; // ebx
  unsigned int v64; // ebp
  int v65; // edi
  unsigned int v66; // eax
  unsigned int v67; // edx
  unsigned int v68; // ebp
  unsigned int v69; // edi
  unsigned int v70; // edx
  int v71; // eax
  unsigned int v72; // ebp
  int v73; // edx
  unsigned int v74; // edi
  unsigned int v75; // ebx
  unsigned int v76; // ebp
  unsigned int v77; // edx
  unsigned int v78; // ebx
  int v79; // edi
  unsigned int v80; // ebp
  int v81; // ebx
  unsigned int v82; // edx
  unsigned int v83; // eax
  unsigned int v84; // ebp
  unsigned int v85; // ebx
  unsigned int v86; // eax
  int v87; // edx
  unsigned int v88; // ebp
  int v89; // eax
  unsigned int v90; // ebx
  unsigned int v91; // edi
  unsigned int v92; // ebp
  unsigned int v93; // eax
  unsigned int v94; // edi
  int v95; // ebx
  unsigned int v96; // ebp
  int v97; // edi
  unsigned int v98; // eax
  int v99; // edx
  unsigned int v100; // edi
  unsigned int v101; // edx
  int v102; // eax
  unsigned int v103; // ebp
  int v104; // edx
  unsigned int v105; // edi
  unsigned int v106; // ebx
  unsigned int v107; // ebp
  unsigned int v108; // edx
  unsigned int v109; // ebx
  unsigned int v110; // edi
  int v111; // ebx
  unsigned int v112; // edx
  unsigned int v113; // ebp
  unsigned int v114; // eax
  unsigned int v115; // ebx
  unsigned int v116; // ebp
  unsigned int v117; // eax
  unsigned int v118; // edi
  int v119; // edx
  unsigned int v120; // eax
  int v121; // ebp
  unsigned int v122; // ebx
  unsigned int v123; // edi
  unsigned int v124; // eax
  unsigned int v125; // ebp
  unsigned int v126; // edi
  int v127; // ebx
  int v128; // edi
  unsigned int v129; // ebp
  unsigned int v130; // eax
  unsigned int v131; // edx
  unsigned int v132; // edi
  unsigned int v133; // eax
  int v134; // ebp
  unsigned int v135; // edx
  int v136; // eax
  unsigned int v137; // edi
  unsigned int v138; // ebx
  unsigned int v139; // edx
  unsigned int v140; // eax
  unsigned int v141; // ebx
  int v142; // edi
  unsigned int v143; // edx
  unsigned int v144; // eax
  unsigned int v145; // ebp
  unsigned int v146; // edi
  int v147; // edi
  unsigned int v148; // ecx
  unsigned int v149; // ebp
  unsigned int v150; // eax
  int v151; // edi
  unsigned int v152; // ecx
  unsigned int v153; // ebp
  unsigned int v154; // edx
  unsigned int v155; // edi
  unsigned int v156; // ebp
  unsigned int v157; // eax
  unsigned int v158; // edi
  int v159; // ebp
  unsigned int v160; // edx
  unsigned int v161; // eax
  unsigned int v162; // edi
  int v163; // edx
  unsigned int v164; // edi
  unsigned int v165; // eax
  char v166; // [esp+10h] [ebp-10h]
  char v167; // [esp+10h] [ebp-10h]
  unsigned int v168; // [esp+14h] [ebp-Ch]
  int v169; // [esp+14h] [ebp-Ch]
  unsigned int v170; // [esp+14h] [ebp-Ch]
  unsigned int v171; // [esp+14h] [ebp-Ch]
  unsigned int v172; // [esp+14h] [ebp-Ch]
  unsigned int v173; // [esp+14h] [ebp-Ch]
  unsigned int v174; // [esp+18h] [ebp-8h]
  unsigned int v175; // [esp+18h] [ebp-8h]
  unsigned int v176; // [esp+18h] [ebp-8h]
  unsigned int v177; // [esp+18h] [ebp-8h]
  unsigned int v178; // [esp+18h] [ebp-8h]
  unsigned int v179; // [esp+1Ch] [ebp-4h]
  unsigned int v180; // [esp+1Ch] [ebp-4h]
  unsigned int v181; // [esp+1Ch] [ebp-4h]
  unsigned int v182; // [esp+1Ch] [ebp-4h]
  unsigned int v183; // [esp+1Ch] [ebp-4h]
  unsigned int v184; // [esp+1Ch] [ebp-4h]
  unsigned int v185; // [esp+1Ch] [ebp-4h]
  unsigned int v186; // [esp+1Ch] [ebp-4h]
  unsigned int v187; // [esp+1Ch] [ebp-4h]
  unsigned int v188; // [esp+1Ch] [ebp-4h]
  unsigned int v189; // [esp+24h] [ebp+4h]
  unsigned int *v190; // [esp+24h] [ebp+4h]
  unsigned int *v191; // [esp+24h] [ebp+4h]
  unsigned int v192; // [esp+24h] [ebp+4h]
  int v193; // [esp+24h] [ebp+4h]
  unsigned int v194; // [esp+24h] [ebp+4h]
  unsigned int *v195; // [esp+24h] [ebp+4h]
  unsigned int *v196; // [esp+2Ch] [ebp+Ch]
  unsigned int *v197; // [esp+2Ch] [ebp+Ch]
  unsigned int *v198; // [esp+2Ch] [ebp+Ch]
  unsigned int *v199; // [esp+2Ch] [ebp+Ch]
  unsigned int *v200; // [esp+2Ch] [ebp+Ch]

  v5 = a3[3] ^ a1[3];
  v189 = *a3 + *a1;
  v179 = SS3[(unsigned __int8)v189] ^ SS0[HIBYTE(v189)] ^ SS2[BYTE1(v189)] ^ SS1[BYTE2(v189)];
  v6 = (unsigned int)*(&S1 + (unsigned __int8)v179) ^ ((S0[BYTE1(v179)] ^ (((S0[HIBYTE(v179)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v179))) << 8)) << 8);
  v168 = v6 + (a3[1] ^ a1[1]);
  v7 = v6 ^ (a3[2] + a1[2]);
  v8 = SS3[(unsigned __int8)v168] ^ SS0[HIBYTE(v168)] ^ SS2[BYTE1(v168)] ^ SS1[BYTE2(v168)];
  v9 = (unsigned int)*(&S1 + (unsigned __int8)v8) ^ ((S0[BYTE1(v8)] ^ (((S0[HIBYTE(v8)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v8))) << 8)) << 8);
  v10 = v9 + v7;
  v11 = v9 ^ __ROL4__(v5, v189 & 0x1F);
  v180 = SS3[(unsigned __int8)v10] ^ SS0[HIBYTE(v10)] ^ SS2[BYTE1(v10)] ^ SS1[BYTE2(v10)];
  v12 = (unsigned int)*(&S1 + (unsigned __int8)v180) ^ ((S0[BYTE1(v180)] ^ (((S0[HIBYTE(v180)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v180))) << 8)) << 8);
  v174 = v12 + v11;
  v190 = (unsigned int *)(v12 ^ __ROL4__(v189, v168 & 0x1F));
  v181 = SS3[(unsigned __int8)(v12 + v11)] ^ SS0[(v12 + v11) >> 24] ^ SS2[(unsigned __int8)((unsigned __int16)(v12 + v11) >> 8)] ^ SS1[(unsigned __int8)((v12 + v11) >> 16)];
  v13 = (unsigned int)*(&S1 + (unsigned __int8)v181) ^ ((S0[BYTE1(v181)] ^ (((S0[HIBYTE(v181)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v181))) << 8)) << 8);
  v191 = (unsigned int *)((char *)v190 + v13);
  v169 = v13 ^ __ROL4__(v168, v10 & 0x1F);
  v182 = SS3[(unsigned __int8)v191] ^ SS0[(unsigned int)v191 >> 24] ^ SS2[BYTE1(v191)] ^ SS1[BYTE2(v191)];
  v14 = (unsigned int)*(&S1 + (unsigned __int8)v182) ^ ((S0[BYTE1(v182)] ^ (((S0[HIBYTE(v182)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v182))) << 8)) << 8);
  v170 = v14 + v169;
  v15 = v14 ^ __ROL4__(v10, v174 & 0x1F);
  v183 = SS3[(unsigned __int8)v170] ^ SS0[HIBYTE(v170)] ^ SS2[BYTE1(v170)] ^ SS1[BYTE2(v170)];
  v16 = (unsigned int)*(&S1 + (unsigned __int8)v183) ^ ((S0[BYTE1(v183)] ^ (((S0[HIBYTE(v183)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v183))) << 8)) << 8);
  v196 = (unsigned int *)(v16 + v15);
  v17 = v16 ^ __ROL4__(v174, (unsigned __int8)v191 & 0x1F);
  v184 = SS3[(unsigned __int8)(v16 + v15)] ^ SS0[(v16 + v15) >> 24] ^ SS2[(unsigned __int8)((unsigned __int16)(v16 + v15) >> 8)] ^ SS1[(unsigned __int8)((v16 + v15) >> 16)];
  v18 = (unsigned int)*(&S1 + (unsigned __int8)v184) ^ ((S0[BYTE1(v184)] ^ (((S0[HIBYTE(v184)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v184))) << 8)) << 8);
  v175 = v18 + v17;
  v19 = v18 ^ __ROL4__(v191, v170 & 0x1F);
  v20 = SS3[(unsigned __int8)(v18 + v17)] ^ SS0[(v18 + v17) >> 24] ^ SS2[(unsigned __int8)((unsigned __int16)(v18 + v17) >> 8)] ^ SS1[(unsigned __int8)((v18 + v17) >> 16)];
  v21 = (unsigned int)*(&S1 + (unsigned __int8)v20) ^ ((S0[BYTE1(v20)] ^ (((S0[HIBYTE(v20)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v20))) << 8)) << 8);
  v22 = a3[5] + (v21 ^ __ROL4__(v170, (unsigned __int8)v196 & 0x1F));
  v23 = a3[4] ^ (v21 + v19);
  v24 = __ROL4__(v196, v175 & 0x1F);
  v25 = v22 ^ v175;
  v197 = (unsigned int *)(v23 + v24);
  v26 = ((v22 ^ v175) + v23 + v24) ^ v22;
  v27 = v23 + v24 + 2 * v25 + v23;
  v28 = (unsigned int)v197 >> (32 - (v26 & 0x1F));
  v29 = (_DWORD)v197 << (v26 & 0x1F);
  v30 = a3[8] ^ v26;
  v31 = a3[9] + (a3[6] ^ (v29 | v28));
  LOBYTE(v29) = v27 & 0x1F;
  v32 = v31 ^ v27;
  v33 = v30 + a3[7] + __ROL4__(v25, v29);
  v34 = (v33 + v32) ^ v31;
  v35 = v33 + 2 * v32 + v30;
  v36 = v33 >> (32 - (v34 & 0x1F));
  v37 = v33 << (v34 & 0x1F);
  v38 = a3[12] ^ v34;
  v39 = a3[13] + (a3[10] ^ (v37 | v36));
  LOBYTE(v37) = v35 & 0x1F;
  v40 = v39 ^ v35;
  v192 = v38 + a3[11] + __ROL4__(v32, v37);
  v41 = (v40 + v192) ^ v39;
  v42 = v192 + 2 * v40 + v38;
  v43 = v192 >> (32 - (v41 & 0x1F));
  v44 = v192 << (v41 & 0x1F);
  v45 = a3[16] ^ v41;
  v46 = a3[17] + (a3[14] ^ (v44 | v43));
  LOBYTE(v44) = v42 & 0x1F;
  v47 = v46 ^ v42;
  v48 = v45 + a3[15] + __ROL4__(v40, v44);
  v49 = (v47 + v48) ^ v46;
  v50 = v48 + 2 * v47 + v45;
  v51 = v48 >> (32 - (v49 & 0x1F));
  v52 = v48 << (v49 & 0x1F);
  v53 = a3[20] ^ v49;
  v54 = a3[21] + (a3[18] ^ (v52 | v51));
  LOBYTE(v52) = v50 & 0x1F;
  v55 = v54 ^ v50;
  v56 = v53 + a3[19] + __ROL4__(v47, v52);
  v57 = (v55 + v56) ^ v54;
  v58 = v56 + 2 * v55 + v53;
  v59 = v56 >> (32 - (v57 & 0x1F));
  v60 = v56 << (v57 & 0x1F);
  v61 = a3[24] ^ v57;
  v62 = a3[25] + (a3[22] ^ (v60 | v59));
  v166 = v58 & 0x1F;
  v63 = v62 ^ v58;
  v64 = v61 + a3[23] + __ROL4__(v55, v166);
  v65 = (v63 + v64) ^ v62;
  v66 = v64 + 2 * v63 + v61;
  v67 = v64 >> (32 - (v65 & 0x1F));
  v68 = v64 << (v65 & 0x1F);
  v69 = a3[28] ^ v65;
  v70 = a3[29] + (a3[26] ^ (v68 | v67));
  LOBYTE(v68) = v66 & 0x1F;
  v71 = v70 ^ v66;
  v72 = v69 + a3[27] + __ROL4__(v63, v68);
  v73 = (v71 + v72) ^ v70;
  v74 = v72 + 2 * v71 + v69;
  v75 = v72 >> (32 - (v73 & 0x1F));
  v76 = v72 << (v73 & 0x1F);
  v77 = a3[32] ^ v73;
  v78 = a3[33] + (a3[30] ^ (v76 | v75));
  LOBYTE(v76) = v74 & 0x1F;
  v79 = v78 ^ v74;
  v80 = v77 + a3[31] + __ROL4__(v71, v76);
  v81 = (v79 + v80) ^ v78;
  v82 = v80 + 2 * v79 + v77;
  v83 = v80 >> (32 - (v81 & 0x1F));
  v84 = v80 << (v81 & 0x1F);
  v85 = a3[36] ^ v81;
  v86 = a3[37] + (a3[34] ^ (v84 | v83));
  LOBYTE(v84) = v82 & 0x1F;
  v87 = v86 ^ v82;
  v88 = v85 + a3[35] + __ROL4__(v79, v84);
  v89 = (v87 + v88) ^ v86;
  v90 = v88 + 2 * v87 + v85;
  v91 = v88 >> (32 - (v89 & 0x1F));
  v92 = v88 << (v89 & 0x1F);
  v93 = a3[40] ^ v89;
  v94 = a3[41] + (a3[38] ^ (v92 | v91));
  LOBYTE(v92) = v90 & 0x1F;
  v95 = v94 ^ v90;
  v96 = v93 + a3[39] + __ROL4__(v87, v92);
  v97 = (v95 + v96) ^ v94;
  v98 = v96 + 2 * v95 + v93;
  v99 = __ROL4__(v96, v97 & 0x1F);
  v100 = a3[44] ^ v97;
  v101 = a3[45] + (a3[42] ^ v99);
  v167 = v98 & 0x1F;
  v102 = v101 ^ v98;
  v103 = v100 + a3[43] + __ROL4__(v95, v167);
  v104 = (v102 + v103) ^ v101;
  v105 = v103 + 2 * v102 + v100;
  v106 = v103 >> (32 - (v104 & 0x1F));
  v107 = v103 << (v104 & 0x1F);
  v108 = a3[48] ^ v104;
  v109 = a3[49] + (a3[46] ^ (v107 | v106));
  LOBYTE(v107) = v105 & 0x1F;
  v110 = v109 ^ v105;
  v171 = v108 + a3[47] + __ROL4__(v102, v107);
  v111 = (v110 + v171) ^ v109;
  v112 = v171 + 2 * v110 + v108;
  v113 = v171 >> (32 - (v111 & 0x1F));
  v114 = v171 << (v111 & 0x1F);
  v115 = a3[52] ^ v111;
  v116 = a3[53] + (a3[50] ^ (v114 | v113));
  v117 = v110 >> (32 - (v112 & 0x1F));
  v118 = v110 << (v112 & 0x1F);
  v119 = v116 ^ v112;
  v120 = v115 + a3[51] + (v118 | v117);
  v121 = (v119 + v120) ^ v116;
  v122 = v120 + 2 * v119 + v115;
  v123 = v120 >> (32 - (v121 & 0x1F));
  v124 = v120 << (v121 & 0x1F);
  v125 = a3[56] ^ v121;
  v126 = a3[57] + (a3[54] ^ (v124 | v123));
  LOBYTE(v124) = v122 & 0x1F;
  v127 = v126 ^ v122;
  v176 = v125 + a3[55] + __ROL4__(v119, v124);
  v128 = (v176 + v127) ^ v126;
  v129 = v176 + 2 * v127 + v125;
  v130 = v176 >> (32 - (v128 & 0x1F));
  v131 = v176 << (v128 & 0x1F);
  v132 = a3[60] ^ v128;
  v133 = a3[61] + (a3[58] ^ (v131 | v130));
  LOBYTE(v131) = v129 & 0x1F;
  v134 = v133 ^ v129;
  v135 = v132 + a3[59] + __ROL4__(v127, v131);
  v136 = (v135 + v134) ^ v133;
  v137 = v135 + 2 * v134 + v132;
  v138 = v135 >> (32 - (v136 & 0x1F));
  v139 = v135 << (v136 & 0x1F);
  v140 = a3[64] ^ v136;
  v141 = a3[65] + (a3[62] ^ (v139 | v138));
  LOBYTE(v139) = v137 & 0x1F;
  v142 = v141 ^ v137;
  v143 = v140 + a3[63] + __ROL4__(v134, v139);
  v144 = v143 + 2 * v142 + v140;
  v193 = (v142 + v143) ^ v141;
  v185 = SS3[(unsigned __int8)v144] ^ SS0[HIBYTE(v144)] ^ SS2[BYTE1(v144)] ^ SS1[BYTE2(v144)];
  v145 = (unsigned int)*(&S1 + (unsigned __int8)v185) ^ ((S0[BYTE1(v185)] ^ (((S0[HIBYTE(v185)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v185))) << 8)) << 8);
  v198 = (unsigned int *)__ROR4__(a3[67] + __ROL4__(v142, v144 & 0x1F), v144 & 0x1F);
  v146 = a3[66] ^ __ROL4__(v143, v193 & 0x1F);
  v194 = v193 - v145;
  v147 = v145 ^ v146;
  v148 = SS3[(unsigned __int8)v198] ^ SS0[(unsigned int)v198 >> 24] ^ SS2[BYTE1(v198)] ^ SS1[BYTE2(v198)];
  v149 = (unsigned int)*(&S1 + (unsigned __int8)v148) ^ ((S0[BYTE1(v148)] ^ (((S0[HIBYTE(v148)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v148))) << 8)) << 8);
  v150 = v144 - v149;
  v172 = __ROR4__(v147, (unsigned __int8)v198 & 0x1F);
  v151 = v149 ^ v194;
  v152 = SS3[(unsigned __int8)v172] ^ SS0[HIBYTE(v172)] ^ SS2[BYTE1(v172)] ^ SS1[BYTE2(v172)];
  v153 = (unsigned int)*(&S1 + (unsigned __int8)v152) ^ ((S0[BYTE1(v152)] ^ (((S0[HIBYTE(v152)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v152))) << 8)) << 8);
  v154 = __ROR4__(v151, v172 & 0x1F);
  v186 = SS3[(unsigned __int8)v154] ^ SS0[HIBYTE(v154)] ^ SS2[BYTE1(v154)] ^ SS1[BYTE2(v154)];
  v155 = (unsigned int)*(&S1 + (unsigned __int8)v186) ^ ((S0[BYTE1(v186)] ^ (((S0[HIBYTE(v186)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v186))) << 8)) << 8);
  v199 = (unsigned int *)(v155 ^ ((unsigned int)v198 - v153));
  v177 = __ROR4__(v153 ^ v150, v154 & 0x1F);
  v156 = v172 - v155;
  v157 = SS3[(unsigned __int8)v177] ^ SS0[HIBYTE(v177)] ^ SS2[BYTE1(v177)] ^ SS1[BYTE2(v177)];
  v158 = (unsigned int)*(&S1 + (unsigned __int8)v157) ^ ((S0[BYTE1(v157)] ^ (((S0[HIBYTE(v157)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v157))) << 8)) << 8);
  v159 = v158 ^ v156;
  v160 = v154 - v158;
  v200 = (unsigned int *)__ROR4__(v199, v177 & 0x1F);
  v161 = SS3[(unsigned __int8)v200] ^ SS0[(unsigned int)v200 >> 24] ^ SS2[BYTE1(v200)] ^ SS1[BYTE2(v200)];
  v162 = (unsigned int)*(&S1 + (unsigned __int8)v161) ^ ((S0[BYTE1(v161)] ^ (((S0[HIBYTE(v161)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v161))) << 8)) << 8);
  v163 = v162 ^ v160;
  v178 = v177 - v162;
  v173 = __ROR4__(v159, (unsigned __int8)v200 & 0x1F);
  v187 = SS3[(unsigned __int8)v173] ^ SS0[HIBYTE(v173)] ^ SS2[BYTE1(v173)] ^ SS1[BYTE2(v173)];
  v164 = (unsigned int)*(&S1 + (unsigned __int8)v187) ^ ((S0[BYTE1(v187)] ^ (((S0[HIBYTE(v187)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v187))) << 8)) << 8);
  v195 = (unsigned int *)__ROR4__(v163, v173 & 0x1F);
  v188 = SS3[(unsigned __int8)v195] ^ SS0[(unsigned int)v195 >> 24] ^ SS2[BYTE1(v195)] ^ SS1[BYTE2(v195)];
  v165 = (unsigned int)*(&S1 + (unsigned __int8)v188) ^ ((S0[BYTE1(v188)] ^ (((S0[HIBYTE(v188)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v188))) << 8)) << 8);
  *a2 = (unsigned int)v195 - a3[68];
  a2[1] = a3[69] ^ (v173 - v165);
  a2[2] = (((unsigned int)v200 - v164) ^ v165) - a3[70];
  a2[3] = a3[71] ^ __ROR4__(v164 ^ v178, (unsigned __int8)v195 & 0x1F);
}
// 400: using guessed type void *S1;

//----- (00002BB0) --------------------------------------------------------
void __cdecl decryption(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v4; // ebp
  unsigned int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // edi
  unsigned int v11; // edi
  unsigned int v12; // edi
  int v13; // edx
  unsigned int v14; // edi
  unsigned int v15; // edx
  int v16; // eax
  unsigned int v17; // edi
  unsigned int v18; // ebp
  int v19; // edi
  int v20; // edx
  int v21; // ebx
  unsigned int v22; // eax
  int v23; // ebp
  int v24; // edx
  unsigned int v25; // ebx
  unsigned int v26; // eax
  int v27; // edi
  int v28; // ebp
  int v29; // edx
  int v30; // eax
  int v31; // edi
  unsigned int v32; // ebp
  unsigned int v33; // edx
  int v34; // ebx
  int v35; // ebp
  int v36; // edi
  int v37; // edx
  int v38; // ebx
  unsigned int v39; // ebp
  unsigned int v40; // edi
  int v41; // eax
  int v42; // ebp
  int v43; // ebx
  int v44; // edi
  int v45; // eax
  unsigned int v46; // ebp
  unsigned int v47; // ebx
  int v48; // edx
  int v49; // ebp
  int v50; // eax
  int v51; // ebx
  int v52; // edx
  unsigned int v53; // ebp
  unsigned int v54; // eax
  int v55; // edi
  int v56; // ebp
  int v57; // edx
  int v58; // eax
  int v59; // edi
  unsigned int v60; // ebp
  unsigned int v61; // edx
  int v62; // ebx
  int v63; // ebp
  int v64; // edi
  int v65; // edx
  int v66; // ebx
  unsigned int v67; // ebp
  unsigned int v68; // edi
  int v69; // eax
  int v70; // ebp
  int v71; // ebx
  int v72; // edi
  int v73; // eax
  unsigned int v74; // ebp
  unsigned int v75; // ebx
  int v76; // edx
  int v77; // ebp
  int v78; // eax
  int v79; // ebx
  int v80; // ebp
  int v81; // edx
  unsigned int v82; // eax
  int v83; // edi
  int v84; // ebp
  int v85; // edx
  int v86; // eax
  int v87; // edi
  unsigned int v88; // ebp
  unsigned int v89; // edx
  int v90; // ebx
  int v91; // ebp
  int v92; // edi
  int v93; // edx
  int v94; // ebx
  unsigned int v95; // ebp
  unsigned int v96; // edi
  int v97; // eax
  int v98; // ebp
  int v99; // ebx
  int v100; // edi
  int v101; // eax
  unsigned int v102; // ebp
  unsigned int v103; // ebx
  int v104; // edx
  int v105; // ebp
  int v106; // eax
  int v107; // ebx
  int v108; // edx
  unsigned int v109; // ebp
  unsigned int v110; // eax
  int v111; // edi
  int v112; // ebp
  int v113; // edx
  int v114; // eax
  int v115; // edi
  unsigned int v116; // ebp
  unsigned int v117; // edx
  int v118; // ebx
  int v119; // ebp
  int v120; // edi
  int v121; // edx
  int v122; // ebx
  unsigned int v123; // ebp
  unsigned int v124; // edi
  int v125; // eax
  int v126; // ebp
  int v127; // edi
  int v128; // ebx
  unsigned int v129; // eax
  unsigned int v130; // ecx
  unsigned int v131; // ebp
  unsigned int v132; // edi
  unsigned int v133; // ecx
  unsigned int v134; // ebp
  int v135; // edi
  unsigned int v136; // eax
  unsigned int v137; // ecx
  unsigned int v138; // ebp
  int v139; // eax
  unsigned int v140; // edx
  unsigned int v141; // edi
  unsigned int v142; // ebp
  unsigned int v143; // eax
  unsigned int v144; // edi
  int v145; // ebp
  unsigned int v146; // edx
  unsigned int v147; // eax
  unsigned int v148; // edi
  int v149; // edx
  unsigned int v150; // edi
  unsigned int v151; // eax
  unsigned int v152; // [esp+10h] [ebp-Ch]
  int v153; // [esp+10h] [ebp-Ch]
  unsigned int v154; // [esp+10h] [ebp-Ch]
  unsigned int v155; // [esp+10h] [ebp-Ch]
  unsigned int v156; // [esp+10h] [ebp-Ch]
  unsigned int v157; // [esp+10h] [ebp-Ch]
  unsigned int v158; // [esp+14h] [ebp-8h]
  int v159; // [esp+14h] [ebp-8h]
  unsigned int v160; // [esp+14h] [ebp-8h]
  unsigned int v161; // [esp+14h] [ebp-8h]
  int v162; // [esp+18h] [ebp-4h]
  unsigned int v163; // [esp+18h] [ebp-4h]
  unsigned int v164; // [esp+18h] [ebp-4h]
  unsigned int v165; // [esp+18h] [ebp-4h]
  unsigned int v166; // [esp+18h] [ebp-4h]
  unsigned int v167; // [esp+20h] [ebp+4h]
  unsigned int *v168; // [esp+20h] [ebp+4h]
  unsigned int *v169; // [esp+20h] [ebp+4h]
  unsigned int *v170; // [esp+20h] [ebp+4h]
  unsigned int *v171; // [esp+20h] [ebp+4h]
  unsigned int *v172; // [esp+20h] [ebp+4h]
  unsigned int v173; // [esp+28h] [ebp+Ch]
  unsigned int v174; // [esp+28h] [ebp+Ch]
  unsigned int v175; // [esp+28h] [ebp+Ch]
  unsigned int v176; // [esp+28h] [ebp+Ch]
  unsigned int v177; // [esp+28h] [ebp+Ch]
  unsigned int v178; // [esp+28h] [ebp+Ch]
  unsigned int v179; // [esp+28h] [ebp+Ch]
  unsigned int v180; // [esp+28h] [ebp+Ch]
  unsigned int v181; // [esp+28h] [ebp+Ch]
  unsigned int v182; // [esp+28h] [ebp+Ch]

  v4 = a1[3] ^ a3[71];
  v158 = *a1 + a3[68];
  v173 = SS3[(unsigned __int8)v158] ^ SS0[HIBYTE(v158)] ^ SS2[BYTE1(v158)] ^ SS1[BYTE2(v158)];
  v5 = (unsigned int)*(&S1 + (unsigned __int8)v173) ^ ((S0[BYTE1(v173)] ^ (((S0[HIBYTE(v173)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v173))) << 8)) << 8);
  v6 = v5 ^ (a1[2] + a3[70]);
  v152 = v5 + (a1[1] ^ a3[69]);
  v7 = SS3[(unsigned __int8)v152] ^ SS0[HIBYTE(v152)] ^ SS2[BYTE1(v152)] ^ SS1[BYTE2(v152)];
  v8 = (unsigned int)*(&S1 + (unsigned __int8)v7) ^ ((S0[BYTE1(v7)] ^ (((S0[HIBYTE(v7)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v7))) << 8)) << 8);
  v167 = v8 + v6;
  v162 = v8 ^ __ROL4__(v4, v158 & 0x1F);
  v9 = SS3[(unsigned __int8)v167] ^ SS0[HIBYTE(v167)] ^ SS2[(unsigned __int8)((unsigned __int16)(v8 + v6) >> 8)] ^ SS1[BYTE2(v167)];
  v10 = (unsigned int)*(&S1 + (unsigned __int8)v9) ^ ((S0[BYTE1(v9)] ^ (((S0[HIBYTE(v9)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v9))) << 8)) << 8);
  v163 = v10 + v162;
  v159 = v10 ^ __ROL4__(v158, v152 & 0x1F);
  v174 = SS3[(unsigned __int8)v163] ^ SS0[HIBYTE(v163)] ^ SS2[BYTE1(v163)] ^ SS1[BYTE2(v163)];
  v11 = (unsigned int)*(&S1
                      + (unsigned __int8)(LOBYTE(SS3[(unsigned __int8)v163]) ^ LOBYTE(SS0[HIBYTE(v163)]) ^ LOBYTE(SS2[BYTE1(v163)]) ^ LOBYTE(SS1[BYTE2(v163)]))) ^ ((S0[BYTE1(v174)] ^ (((S0[HIBYTE(v174)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v174))) << 8)) << 8);
  v160 = v11 + v159;
  v153 = v11 ^ __ROL4__(v152, v167 & 0x1F);
  v175 = SS3[(unsigned __int8)v160] ^ SS0[HIBYTE(v160)] ^ SS2[BYTE1(v160)] ^ SS1[BYTE2(v160)];
  v12 = (unsigned int)*(&S1 + (unsigned __int8)v175) ^ ((S0[BYTE1(v175)] ^ (((S0[HIBYTE(v175)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v175))) << 8)) << 8);
  v154 = v12 + v153;
  v13 = v12 ^ __ROL4__(v167, v163 & 0x1F);
  v176 = SS3[(unsigned __int8)v154] ^ SS0[HIBYTE(v154)] ^ SS2[BYTE1(v154)] ^ SS1[BYTE2(v154)];
  v14 = (unsigned int)*(&S1 + (unsigned __int8)v176) ^ ((S0[BYTE1(v176)] ^ (((S0[HIBYTE(v176)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v176))) << 8)) << 8);
  v15 = v14 + v13;
  v16 = v14 ^ __ROL4__(v163, v160 & 0x1F);
  v177 = SS3[(unsigned __int8)v15] ^ SS0[HIBYTE(v15)] ^ SS2[BYTE1(v15)] ^ SS1[BYTE2(v15)];
  v17 = (unsigned int)*(&S1 + (unsigned __int8)v177) ^ ((S0[BYTE1(v177)] ^ (((S0[HIBYTE(v177)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v177))) << 8)) << 8);
  v164 = v17 + v16;
  v178 = SS3[(unsigned __int8)(v17 + v16)] ^ SS0[(v17 + v16) >> 24] ^ SS2[(unsigned __int8)((unsigned __int16)(v17 + v16) >> 8)] ^ SS1[(unsigned __int8)((v17 + v16) >> 16)];
  v179 = (unsigned int)*(&S1 + (unsigned __int8)v178) ^ ((S0[BYTE1(v178)] ^ (((S0[HIBYTE(v178)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v178))) << 8)) << 8);
  v18 = v179 + (v17 ^ __ROL4__(v160, v154 & 0x1F));
  v19 = v179 ^ __ROL4__(v154, v15 & 0x1F);
  v20 = __ROR4__(__ROL4__(v15, v164 & 0x1F) - a3[67], v164 & 0x1F);
  v21 = __ROR4__(a3[66] ^ v19, v18 & 0x1F);
  v22 = -v21 - 2 * v20 + v164;
  v23 = (v20 + v21) ^ v18;
  v24 = v23 ^ v20;
  v25 = v21 - v22 - a3[63];
  v26 = a3[64] ^ v22;
  v27 = __ROR4__(v25, v24 & 0x1F);
  v28 = __ROR4__(a3[62] ^ (v23 - a3[65]), v26 & 0x1F);
  v29 = -v28 - 2 * v27 + v24;
  v30 = (v27 + v28) ^ v26;
  v31 = v30 ^ v27;
  v32 = v28 - v29 - a3[59];
  v33 = a3[60] ^ v29;
  v34 = __ROR4__(v32, v31 & 0x1F);
  v35 = __ROR4__(a3[58] ^ (v30 - a3[61]), v33 & 0x1F);
  v36 = -v35 - 2 * v34 + v31;
  v37 = (v34 + v35) ^ v33;
  v38 = v37 ^ v34;
  v39 = v35 - v36 - a3[55];
  v40 = a3[56] ^ v36;
  v41 = __ROR4__(v39, v38 & 0x1F);
  v42 = __ROR4__(a3[54] ^ (v37 - a3[57]), v40 & 0x1F);
  v43 = -v42 - 2 * v41 + v38;
  v44 = (v41 + v42) ^ v40;
  v45 = v44 ^ v41;
  v46 = v42 - v43 - a3[51];
  v47 = a3[52] ^ v43;
  v48 = __ROR4__(v46, v45 & 0x1F);
  v49 = __ROR4__(a3[50] ^ (v44 - a3[53]), v47 & 0x1F);
  v50 = -v49 - 2 * v48 + v45;
  v51 = (v48 + v49) ^ v47;
  v52 = v51 ^ v48;
  v53 = v49 - v50 - a3[47];
  v54 = a3[48] ^ v50;
  v55 = __ROR4__(v53, v52 & 0x1F);
  v56 = __ROR4__(a3[46] ^ (v51 - a3[49]), v54 & 0x1F);
  v57 = -v56 - 2 * v55 + v52;
  v58 = (v55 + v56) ^ v54;
  v59 = v58 ^ v55;
  v60 = v56 - v57 - a3[43];
  v61 = a3[44] ^ v57;
  v62 = __ROR4__(v60, v59 & 0x1F);
  v63 = __ROR4__(a3[42] ^ (v58 - a3[45]), v61 & 0x1F);
  v64 = -v63 - 2 * v62 + v59;
  v65 = (v62 + v63) ^ v61;
  v66 = v65 ^ v62;
  v67 = v63 - v64 - a3[39];
  v68 = a3[40] ^ v64;
  v69 = __ROR4__(v67, v66 & 0x1F);
  v70 = __ROR4__(a3[38] ^ (v65 - a3[41]), v68 & 0x1F);
  v71 = -v70 - 2 * v69 + v66;
  v72 = (v69 + v70) ^ v68;
  v73 = v72 ^ v69;
  v74 = v70 - v71 - a3[35];
  v75 = a3[36] ^ v71;
  v76 = __ROR4__(v74, v73 & 0x1F);
  v77 = __ROR4__(a3[34] ^ (v72 - a3[37]), v75 & 0x1F);
  v78 = -v77 - 2 * v76 + v73;
  v79 = (v76 + v77) ^ v75;
  v80 = v77 - v78;
  v81 = v79 ^ v76;
  v82 = a3[32] ^ v78;
  v83 = __ROR4__(v80 - a3[31], v81 & 0x1F);
  v84 = __ROR4__(a3[30] ^ (v79 - a3[33]), v82 & 0x1F);
  v85 = -v84 - 2 * v83 + v81;
  v86 = (v83 + v84) ^ v82;
  v87 = v86 ^ v83;
  v88 = v84 - v85 - a3[27];
  v89 = a3[28] ^ v85;
  v90 = __ROR4__(v88, v87 & 0x1F);
  v91 = __ROR4__(a3[26] ^ (v86 - a3[29]), v89 & 0x1F);
  v92 = -v91 - 2 * v90 + v87;
  v93 = (v90 + v91) ^ v89;
  v94 = v93 ^ v90;
  v95 = v91 - v92 - a3[23];
  v96 = a3[24] ^ v92;
  v97 = __ROR4__(v95, v94 & 0x1F);
  v98 = __ROR4__(a3[22] ^ (v93 - a3[25]), v96 & 0x1F);
  v99 = -v98 - 2 * v97 + v94;
  v100 = (v97 + v98) ^ v96;
  v101 = v100 ^ v97;
  v102 = v98 - v99 - a3[19];
  v103 = a3[20] ^ v99;
  v104 = __ROR4__(v102, v101 & 0x1F);
  v105 = __ROR4__(a3[18] ^ (v100 - a3[21]), v103 & 0x1F);
  v106 = -v105 - 2 * v104 + v101;
  v107 = (v104 + v105) ^ v103;
  v108 = v107 ^ v104;
  v109 = v105 - v106 - a3[15];
  v110 = a3[16] ^ v106;
  v111 = __ROR4__(v109, v108 & 0x1F);
  v112 = __ROR4__(a3[14] ^ (v107 - a3[17]), v110 & 0x1F);
  v113 = -v112 - 2 * v111 + v108;
  v114 = (v111 + v112) ^ v110;
  v115 = v114 ^ v111;
  v116 = v112 - v113 - a3[11];
  v117 = a3[12] ^ v113;
  v118 = __ROR4__(v116, v115 & 0x1F);
  v119 = __ROR4__(a3[10] ^ (v114 - a3[13]), v117 & 0x1F);
  v120 = -v119 - 2 * v118 + v115;
  v121 = (v118 + v119) ^ v117;
  v122 = v121 ^ v118;
  v123 = v119 - v120 - a3[7];
  v124 = a3[8] ^ v120;
  v125 = __ROR4__(v123, v122 & 0x1F);
  v126 = __ROR4__(a3[6] ^ (v121 - a3[9]), v124 & 0x1F);
  v127 = (v125 + v126) ^ v124;
  v128 = -v126 - 2 * v125 + v122;
  v129 = v127 ^ v125;
  v168 = (unsigned int *)(v126 - v128);
  v130 = SS3[(unsigned __int8)v129] ^ SS0[HIBYTE(v129)] ^ SS2[BYTE1(v129)] ^ SS1[BYTE2(v129)];
  v131 = (unsigned int)*(&S1 + (unsigned __int8)v130) ^ ((S0[BYTE1(v130)] ^ (((S0[HIBYTE(v130)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v130))) << 8)) << 8);
  v169 = (unsigned int *)__ROR4__(v168, v129 & 0x1F);
  v155 = v131 ^ (v127 - a3[5]);
  v132 = (v128 ^ a3[4]) - v131;
  v133 = SS3[(unsigned __int8)v169] ^ SS0[(unsigned int)v169 >> 24] ^ SS2[BYTE1(v169)] ^ SS1[BYTE2(v169)];
  v134 = (unsigned int)*(&S1 + (unsigned __int8)v133) ^ ((S0[BYTE1(v133)] ^ (((S0[HIBYTE(v133)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v133))) << 8)) << 8);
  v135 = v134 ^ v132;
  v136 = v129 - v134;
  v156 = __ROR4__(v155, (unsigned __int8)v169 & 0x1F);
  v137 = SS3[(unsigned __int8)v156] ^ SS0[HIBYTE(v156)] ^ SS2[BYTE1(v156)] ^ SS1[BYTE2(v156)];
  v138 = (unsigned int)*(&S1 + (unsigned __int8)v137) ^ ((S0[BYTE1(v137)] ^ (((S0[HIBYTE(v137)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v137))) << 8)) << 8);
  v139 = v138 ^ v136;
  v170 = (unsigned int *)((char *)v169 - v138);
  v140 = __ROR4__(v135, v156 & 0x1F);
  v180 = SS3[(unsigned __int8)v140] ^ SS0[HIBYTE(v140)] ^ SS2[BYTE1(v140)] ^ SS1[BYTE2(v140)];
  v141 = (unsigned int)*(&S1 + (unsigned __int8)v180) ^ ((S0[BYTE1(v180)] ^ (((S0[HIBYTE(v180)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v180))) << 8)) << 8);
  v142 = v156 - v141;
  v171 = (unsigned int *)(v141 ^ (unsigned int)v170);
  v165 = __ROR4__(v139, v140 & 0x1F);
  v143 = SS3[(unsigned __int8)v165] ^ SS0[HIBYTE(v165)] ^ SS2[BYTE1(v165)] ^ SS1[BYTE2(v165)];
  v144 = (unsigned int)*(&S1
                       + (unsigned __int8)(LOBYTE(SS3[(unsigned __int8)v165]) ^ LOBYTE(SS0[HIBYTE(v165)]) ^ LOBYTE(SS2[BYTE1(v165)]) ^ LOBYTE(SS1[BYTE2(v165)]))) ^ ((S0[BYTE1(v143)] ^ (((S0[HIBYTE(v143)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v143))) << 8)) << 8);
  v145 = v144 ^ v142;
  v146 = v140 - v144;
  v172 = (unsigned int *)__ROR4__(v171, v165 & 0x1F);
  v147 = SS3[(unsigned __int8)v172] ^ SS0[(unsigned int)v172 >> 24] ^ SS2[BYTE1(v172)] ^ SS1[BYTE2(v172)];
  v148 = (unsigned int)*(&S1 + (unsigned __int8)v147) ^ ((S0[BYTE1(v147)] ^ (((S0[HIBYTE(v147)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v147))) << 8)) << 8);
  v149 = v148 ^ v146;
  v166 = v165 - v148;
  v157 = __ROR4__(v145, (unsigned __int8)v172 & 0x1F);
  v181 = SS3[(unsigned __int8)v157] ^ SS0[HIBYTE(v157)] ^ SS2[BYTE1(v157)] ^ SS1[BYTE2(v157)];
  v150 = (unsigned int)*(&S1 + (unsigned __int8)v181) ^ ((S0[BYTE1(v181)] ^ (((S0[HIBYTE(v181)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v181))) << 8)) << 8);
  v161 = __ROR4__(v149, v157 & 0x1F);
  v182 = SS3[(unsigned __int8)v161] ^ SS0[HIBYTE(v161)] ^ SS2[BYTE1(v161)] ^ SS1[BYTE2(v161)];
  v151 = (unsigned int)*(&S1 + (unsigned __int8)v182) ^ ((S0[BYTE1(v182)] ^ (((S0[HIBYTE(v182)] << 8) ^ (unsigned int)*(&S1 + BYTE2(v182))) << 8)) << 8);
  *a2 = v161 - *a3;
  a2[1] = a3[1] ^ (v157 - v151);
  a2[2] = (((unsigned int)v172 - v150) ^ v151) - a3[2];
  a2[3] = a3[3] ^ __ROR4__(v150 ^ v166, v161 & 0x1F);
}
// 400: using guessed type void *S1;

//----- (00003D40) --------------------------------------------------------
void __cdecl BufEncryptionECB(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  int v4; // edi
  unsigned __int8 *v5; // esi
  unsigned int *v6; // ecx
  unsigned __int8 *v7; // edi
  int v8; // ebp
  int i; // eax
  int v10; // edx
  unsigned int *v11; // ebp
  int v12; // edx
  unsigned int v13; // edi
  int j; // eax
  char v15; // cl
  unsigned int v16[4]; // [esp+0h] [ebp-20h] BYREF
  unsigned int v17[4]; // [esp+10h] [ebp-10h] BYREF
  int v18; // [esp+28h] [ebp+8h]
  unsigned __int8 *v19; // [esp+2Ch] [ebp+Ch]

  if ( a2 / 16 > 0 )
  {
    v4 = a1 - a3;
    v5 = a3;
    v19 = (unsigned __int8 *)(a1 - a3);
    v18 = a2 / 16;
    while ( 1 )
    {
      v6 = v16;
      v7 = &v5[v4];
      v8 = 4;
      do
      {
        for ( i = 0; i < 4; ++i )
        {
          v10 = (*v6 << 8) ^ v7[i];
          *v6 = v10;
        }
        ++v6;
        v7 += 4;
        --v8;
      }
      while ( v8 );
      encryption(v16, v17, a4);
      v11 = v17;
      v12 = 4;
      do
      {
        v13 = *v11;
        for ( j = 0; j < 32; j += 8 )
        {
          v15 = 24 - j;
          *v5++ = v13 >> v15;
        }
        ++v11;
        --v12;
      }
      while ( v12 );
      if ( !--v18 )
        break;
      v4 = (int)v19;
    }
  }
}

//----- (00003E00) --------------------------------------------------------
void __cdecl BufDecryptionECB(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  int v4; // edi
  unsigned __int8 *v5; // esi
  unsigned int *v6; // ecx
  unsigned __int8 *v7; // edi
  int v8; // ebp
  int i; // eax
  int v10; // edx
  unsigned int *v11; // ebp
  int v12; // edx
  unsigned int v13; // edi
  int j; // eax
  char v15; // cl
  unsigned int v16[4]; // [esp+0h] [ebp-20h] BYREF
  unsigned int v17[4]; // [esp+10h] [ebp-10h] BYREF
  int v18; // [esp+28h] [ebp+8h]
  unsigned __int8 *v19; // [esp+2Ch] [ebp+Ch]

  if ( a2 / 16 > 0 )
  {
    v4 = a1 - a3;
    v5 = a3;
    v19 = (unsigned __int8 *)(a1 - a3);
    v18 = a2 / 16;
    while ( 1 )
    {
      v6 = v16;
      v7 = &v5[v4];
      v8 = 4;
      do
      {
        for ( i = 0; i < 4; ++i )
        {
          v10 = (*v6 << 8) ^ v7[i];
          *v6 = v10;
        }
        ++v6;
        v7 += 4;
        --v8;
      }
      while ( v8 );
      decryption(v16, v17, a4);
      v11 = v17;
      v12 = 4;
      do
      {
        v13 = *v11;
        for ( j = 0; j < 32; j += 8 )
        {
          v15 = 24 - j;
          *v5++ = v13 >> v15;
        }
        ++v11;
        --v12;
      }
      while ( v12 );
      if ( !--v18 )
        break;
      v4 = (int)v19;
    }
  }
}

//----- (00003EC0) --------------------------------------------------------
void __cdecl BufEncryptionCBC(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // edi
  int i; // ecx
  int j; // eax
  unsigned int v8; // edx
  int k; // ebp
  unsigned int v10; // edi
  int v11; // eax
  char v12; // cl
  unsigned int v13[8]; // [esp+0h] [ebp-30h] BYREF
  unsigned int v14[4]; // [esp+20h] [ebp-10h] BYREF
  int v15; // [esp+38h] [ebp+8h]

  v13[0] = 305419896;
  v13[1] = 1450727032;
  v13[2] = -1698933128;
  v13[3] = -553691528;
  if ( a2 / 16 > 0 )
  {
    v4 = a3;
    v15 = a2 / 16;
    do
    {
      v5 = &v4[a1 - a3];
      for ( i = 0; i < 4; ++i )
      {
        for ( j = 0; j < 4; ++j )
        {
          v8 = (v13[i + 4] << 8) ^ v5[j];
          v13[i + 4] = v8;
        }
        v5 += 4;
        v13[i] ^= v8;
      }
      encryption(v13, v14, a4);
      for ( k = 0; k < 4; ++k )
      {
        v10 = v14[k];
        v11 = 0;
        v13[k] = v10;
        do
        {
          v12 = 24 - v11;
          v11 += 8;
          *v4++ = v10 >> v12;
        }
        while ( v11 < 32 );
      }
      --v15;
    }
    while ( v15 );
  }
}

//----- (00003FA0) --------------------------------------------------------
void __cdecl BufDecryptionCBC(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  int v4; // esi
  unsigned __int8 *v5; // edi
  unsigned int *v6; // ecx
  unsigned __int8 *v7; // esi
  int v8; // ebp
  int i; // eax
  int v10; // edx
  int j; // esi
  unsigned int v12; // eax
  int v13; // ecx
  unsigned int v14; // ebp
  int k; // eax
  char v16; // cl
  int v17[4]; // [esp+0h] [ebp-40h]
  unsigned int v18[4]; // [esp+10h] [ebp-30h] BYREF
  unsigned int v19[8]; // [esp+20h] [ebp-20h] BYREF
  int v20; // [esp+48h] [ebp+8h]
  unsigned __int8 *v21; // [esp+4Ch] [ebp+Ch]

  v17[0] = 305419896;
  v17[1] = 1450727032;
  v17[2] = -1698933128;
  v17[3] = -553691528;
  if ( a2 / 16 > 0 )
  {
    v4 = a1 - a3;
    v5 = a3;
    v21 = (unsigned __int8 *)(a1 - a3);
    v20 = a2 / 16;
    while ( 1 )
    {
      v6 = v18;
      v7 = &v5[v4];
      v8 = 4;
      do
      {
        for ( i = 0; i < 4; ++i )
        {
          v10 = (*v6 << 8) ^ v7[i];
          *v6 = v10;
        }
        ++v6;
        v7 += 4;
        --v8;
      }
      while ( v8 );
      decryption(v18, v19, a4);
      for ( j = 0; j < 4; ++j )
      {
        v12 = v17[j] ^ v19[j];
        v13 = v18[j];
        v19[j + 4] = v12;
        v14 = v12;
        v17[j] = v13;
        for ( k = 0; k < 32; k += 8 )
        {
          v16 = 24 - k;
          *v5++ = v14 >> v16;
        }
      }
      if ( !--v20 )
        break;
      v4 = (int)v21;
    }
  }
}

//----- (00004090) --------------------------------------------------------
void __cdecl BufEncryptionCFB(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  int v4; // edi
  bool v5; // zf
  bool v6; // sf
  signed int v7; // esi
  int v8; // esi
  unsigned __int8 *v9; // ebp
  int *v10; // ecx
  unsigned __int8 *v11; // esi
  int v12; // edi
  int i; // eax
  int v14; // edx
  unsigned __int8 *v15; // edi
  int j; // ebp
  unsigned int v17; // esi
  int v18; // eax
  char v19; // cl
  int v20; // esi
  unsigned __int8 *v21; // ebp
  int *v22; // ecx
  unsigned __int8 *v23; // esi
  int v24; // edi
  int k; // eax
  int v26; // edx
  unsigned __int8 *v27; // edi
  int l; // ebp
  unsigned int v29; // esi
  int v30; // eax
  char v31; // cl
  int v32; // ebx
  int v33; // esi
  int *v34; // esi
  unsigned __int8 *v35; // ecx
  int v36; // edi
  int ii; // eax
  int v38; // edx
  int v39; // ebp
  unsigned __int8 *v40; // edi
  unsigned int v41; // esi
  int v42; // eax
  char v43; // cl
  int *v44; // esi
  unsigned __int8 *v45; // ecx
  int v46; // edi
  int m; // eax
  int v48; // edx
  int n; // eax
  int v50; // ecx
  int v51; // ebp
  unsigned __int8 *v52; // edi
  unsigned int v53; // esi
  int v54; // eax
  char v55; // cl
  unsigned int v56; // edi
  int v57; // eax
  int v58; // esi
  char v59; // cl
  int v60; // [esp+10h] [ebp-3Ch]
  int v61; // [esp+14h] [ebp-38h]
  int v62; // [esp+14h] [ebp-38h]
  signed int v63; // [esp+18h] [ebp-34h]
  int v64[4]; // [esp+1Ch] [ebp-30h] BYREF
  unsigned int v65[4]; // [esp+2Ch] [ebp-20h] BYREF
  unsigned int v66[4]; // [esp+3Ch] [ebp-10h] BYREF
  unsigned __int8 *v67; // [esp+50h] [ebp+4h]
  int v68; // [esp+54h] [ebp+8h]

  v65[0] = 305419896;
  v65[1] = 1450727032;
  v65[2] = -1698933128;
  v4 = a2 / 16;
  v7 = a2 & 0x8000000F;
  v5 = (a2 & 0x8000000F) == 0;
  v6 = a2 < 0;
  v65[3] = -553691528;
  v68 = a2 / 16;
  if ( v6 )
  {
    v7 = (((_BYTE)v7 - 1) | 0xFFFFFFF0) + 1;
    v5 = v7 == 0;
  }
  v63 = v7;
  if ( v5 )
  {
    if ( v4 > 0 )
    {
      v8 = a1 - a3;
      v9 = a3;
      v60 = a1 - a3;
      v67 = (unsigned __int8 *)v4;
      while ( 1 )
      {
        v10 = v64;
        v11 = &v9[v8];
        v12 = 4;
        do
        {
          for ( i = 0; i < 4; ++i )
          {
            v14 = (*v10 << 8) ^ v11[i];
            *v10 = v14;
          }
          ++v10;
          v11 += 4;
          --v12;
        }
        while ( v12 );
        encryption(v65, v66, a4);
        v15 = v9;
        for ( j = 0; j < 4; ++j )
        {
          v17 = v64[j] ^ v66[j];
          v18 = 0;
          v65[j] = v17;
          do
          {
            v19 = 24 - v18;
            v18 += 8;
            *v15++ = v17 >> v19;
          }
          while ( v18 < 32 );
        }
        v9 = v15;
        if ( !--v67 )
          break;
        v8 = v60;
      }
    }
  }
  else
  {
    if ( v4 > 0 )
    {
      v20 = a1 - a3;
      v21 = a3;
      v61 = v4;
      while ( 1 )
      {
        v22 = v64;
        v23 = &v21[v20];
        v24 = 4;
        do
        {
          for ( k = 0; k < 4; ++k )
          {
            v26 = (*v22 << 8) ^ v23[k];
            *v22 = v26;
          }
          ++v22;
          v23 += 4;
          --v24;
        }
        while ( v24 );
        encryption(v65, v66, a4);
        v27 = v21;
        for ( l = 0; l < 4; ++l )
        {
          v29 = v64[l] ^ v66[l];
          v30 = 0;
          v65[l] = v29;
          do
          {
            v31 = 24 - v30;
            v30 += 8;
            *v27++ = v29 >> v31;
          }
          while ( v30 < 32 );
        }
        v21 = v27;
        if ( !--v61 )
          break;
        v20 = a1 - a3;
      }
      v4 = v68;
      v7 = v63;
    }
    v32 = v7 / 4;
    v33 = v7 % 4;
    v62 = v33;
    if ( v33 )
    {
      if ( v32 > 0 )
      {
        v44 = v64;
        v45 = &a1[16 * v4];
        v46 = v32;
        do
        {
          for ( m = 0; m < 4; ++m )
          {
            v48 = (*v44 << 8) ^ v45[m];
            *v44 = v48;
          }
          ++v44;
          v45 += 4;
          --v46;
        }
        while ( v46 );
        v4 = v68;
        v33 = v62;
      }
      for ( n = 0; n < v33; v64[v32] = v50 )
        v50 = (v64[v32] << 8) ^ a1[16 * v4 + 4 * v32 + n++];
      v64[v32] <<= 32 - 8 * v33;
      encryption(v65, v66, a4);
      v51 = 0;
      if ( v32 > 0 )
      {
        v52 = &a3[16 * v4];
        do
        {
          v53 = v64[v51] ^ v66[v51];
          v54 = 0;
          v65[v51] = v53;
          do
          {
            v55 = 24 - v54;
            v54 += 8;
            *v52++ = v53 >> v55;
          }
          while ( v54 < 32 );
          ++v51;
        }
        while ( v51 < v32 );
      }
      v56 = v64[v32] ^ v66[v32];
      v57 = 0;
      v65[v32] = v56;
      if ( v62 > 0 )
      {
        v58 = 0;
        do
        {
          v59 = 24 - v58;
          v58 += 8;
          a3[16 * v68 - 1 + 4 * v32 + ++v57] = v56 >> v59;
        }
        while ( v57 < v62 );
      }
    }
    else
    {
      if ( v32 > 0 )
      {
        v34 = v64;
        v35 = &a1[16 * v4];
        v36 = v32;
        do
        {
          for ( ii = 0; ii < 4; ++ii )
          {
            v38 = (*v34 << 8) ^ v35[ii];
            *v34 = v38;
          }
          ++v34;
          v35 += 4;
          --v36;
        }
        while ( v36 );
        v4 = v68;
      }
      encryption(v65, v66, a4);
      v39 = 0;
      if ( v32 > 0 )
      {
        v40 = &a3[16 * v4];
        do
        {
          v41 = v64[v39] ^ v66[v39];
          v42 = 0;
          v65[v39] = v41;
          do
          {
            v43 = 24 - v42;
            v42 += 8;
            *v40++ = v41 >> v43;
          }
          while ( v42 < 32 );
          ++v39;
        }
        while ( v39 < v32 );
      }
    }
  }
}

//----- (00004410) --------------------------------------------------------
void __cdecl BufDecryptionCFB(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  int v4; // ecx
  bool v5; // zf
  bool v6; // sf
  signed int v7; // esi
  int v8; // edi
  unsigned __int8 *v9; // esi
  int *v10; // ecx
  unsigned __int8 *v11; // edi
  int v12; // ebp
  int i; // eax
  int v14; // edx
  int j; // edi
  int v16; // eax
  unsigned int v17; // ebp
  int k; // eax
  char v19; // cl
  int v20; // edi
  unsigned __int8 *v21; // esi
  int *v22; // ecx
  unsigned __int8 *v23; // edi
  int v24; // ebp
  int l; // eax
  int v26; // edx
  int m; // edi
  int v28; // eax
  unsigned int v29; // ebp
  int n; // eax
  char v31; // cl
  int v32; // ebx
  int v33; // esi
  int *v34; // esi
  unsigned __int8 *v35; // ecx
  int v36; // edi
  int jj; // eax
  int v38; // edx
  int v39; // ebp
  unsigned __int8 *v40; // edi
  unsigned int v41; // esi
  int v42; // eax
  char v43; // cl
  int *v44; // esi
  unsigned __int8 *v45; // ecx
  int v46; // edi
  int ii; // eax
  int v48; // edx
  int v49; // eax
  unsigned __int8 *v50; // edi
  int v51; // ecx
  int v52; // ebp
  unsigned __int8 *v53; // edi
  unsigned int v54; // esi
  int v55; // eax
  char v56; // cl
  unsigned int v57; // edi
  int v58; // eax
  int v59; // esi
  char v60; // cl
  int v61; // [esp+10h] [ebp-4Ch]
  int v62; // [esp+14h] [ebp-48h]
  int v63; // [esp+14h] [ebp-48h]
  signed int v64; // [esp+18h] [ebp-44h]
  int v65[4]; // [esp+1Ch] [ebp-40h] BYREF
  unsigned int v66[4]; // [esp+2Ch] [ebp-30h] BYREF
  unsigned int v67[8]; // [esp+3Ch] [ebp-20h] BYREF
  unsigned __int8 *v68; // [esp+60h] [ebp+4h]
  int v69; // [esp+64h] [ebp+8h]

  v66[0] = 305419896;
  v66[1] = 1450727032;
  v66[2] = -1698933128;
  v4 = a2 / 16;
  v7 = a2 & 0x8000000F;
  v5 = (a2 & 0x8000000F) == 0;
  v6 = a2 < 0;
  v66[3] = -553691528;
  v69 = a2 / 16;
  if ( v6 )
  {
    v7 = (((_BYTE)v7 - 1) | 0xFFFFFFF0) + 1;
    v5 = v7 == 0;
  }
  v64 = v7;
  if ( v5 )
  {
    if ( v4 > 0 )
    {
      v8 = a1 - a3;
      v9 = a3;
      v61 = a1 - a3;
      v68 = (unsigned __int8 *)v4;
      while ( 1 )
      {
        v10 = v65;
        v11 = &v9[v8];
        v12 = 4;
        do
        {
          for ( i = 0; i < 4; ++i )
          {
            v14 = (*v10 << 8) ^ v11[i];
            *v10 = v14;
          }
          ++v10;
          v11 += 4;
          --v12;
        }
        while ( v12 );
        encryption(v66, v67, a4);
        for ( j = 0; j < 4; ++j )
        {
          v16 = v65[j];
          v17 = v16 ^ v67[j];
          v66[j] = v16;
          v67[j + 4] = v17;
          for ( k = 0; k < 32; k += 8 )
          {
            v19 = 24 - k;
            *v9++ = v17 >> v19;
          }
        }
        if ( !--v68 )
          break;
        v8 = v61;
      }
    }
  }
  else
  {
    if ( v4 > 0 )
    {
      v20 = a1 - a3;
      v21 = a3;
      v62 = v4;
      while ( 1 )
      {
        v22 = v65;
        v23 = &v21[v20];
        v24 = 4;
        do
        {
          for ( l = 0; l < 4; ++l )
          {
            v26 = (*v22 << 8) ^ v23[l];
            *v22 = v26;
          }
          ++v22;
          v23 += 4;
          --v24;
        }
        while ( v24 );
        encryption(v66, v67, a4);
        for ( m = 0; m < 4; ++m )
        {
          v28 = v65[m];
          v29 = v28 ^ v67[m];
          v66[m] = v28;
          v67[m + 4] = v29;
          for ( n = 0; n < 32; n += 8 )
          {
            v31 = 24 - n;
            *v21++ = v29 >> v31;
          }
        }
        if ( !--v62 )
          break;
        v20 = a1 - a3;
      }
      v4 = v69;
      v7 = v64;
    }
    v32 = v7 / 4;
    v33 = v7 % 4;
    v63 = v33;
    if ( v33 )
    {
      if ( v32 > 0 )
      {
        v44 = v65;
        v45 = &a1[16 * v4];
        v46 = v32;
        do
        {
          for ( ii = 0; ii < 4; ++ii )
          {
            v48 = (*v44 << 8) ^ v45[ii];
            *v44 = v48;
          }
          ++v44;
          v45 += 4;
          --v46;
        }
        while ( v46 );
        v4 = v69;
        v33 = v63;
      }
      v49 = 0;
      if ( v33 > 0 )
      {
        v50 = &a1[16 * v4 + 4 * v32];
        do
        {
          v51 = (v65[v32] << 8) ^ v50[v49++];
          v65[v32] = v51;
        }
        while ( v49 < v33 );
      }
      v65[v32] <<= 32 - 8 * v33;
      encryption(v66, v67, a4);
      v52 = 0;
      if ( v32 > 0 )
      {
        v53 = &a3[16 * v69];
        do
        {
          v54 = v65[v52] ^ v67[v52];
          v55 = 0;
          v67[v52 + 4] = v54;
          do
          {
            v56 = 24 - v55;
            v55 += 8;
            *v53++ = v54 >> v56;
          }
          while ( v55 < 32 );
          ++v52;
        }
        while ( v52 < v32 );
      }
      v57 = v65[v32] ^ v67[v32];
      v58 = 0;
      v67[v32 + 4] = v57;
      if ( v63 > 0 )
      {
        v59 = 0;
        do
        {
          v60 = 24 - v59;
          v59 += 8;
          a3[16 * v69 - 1 + 4 * v32 + ++v58] = v57 >> v60;
        }
        while ( v58 < v63 );
      }
    }
    else
    {
      if ( v32 > 0 )
      {
        v34 = v65;
        v35 = &a1[16 * v4];
        v36 = v32;
        do
        {
          for ( jj = 0; jj < 4; ++jj )
          {
            v38 = (*v34 << 8) ^ v35[jj];
            *v34 = v38;
          }
          ++v34;
          v35 += 4;
          --v36;
        }
        while ( v36 );
      }
      encryption(v66, v67, a4);
      v39 = 0;
      if ( v32 > 0 )
      {
        v40 = &a3[16 * v69];
        do
        {
          v41 = v65[v39] ^ v67[v39];
          v42 = 0;
          v67[v39 + 4] = v41;
          do
          {
            v43 = 24 - v42;
            v42 += 8;
            *v40++ = v41 >> v43;
          }
          while ( v42 < 32 );
          ++v39;
        }
        while ( v39 < v32 );
      }
    }
  }
}

//----- (00004790) --------------------------------------------------------
void __cdecl BufEncryptionOFB(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  int v4; // ebp
  bool v5; // zf
  bool v6; // sf
  signed int v7; // esi
  int v8; // edi
  unsigned __int8 *v9; // esi
  int *v10; // ecx
  unsigned __int8 *v11; // edi
  int v12; // ebp
  int i; // eax
  int v14; // edx
  int j; // edi
  unsigned int v16; // eax
  unsigned int v17; // ebp
  int k; // eax
  char v19; // cl
  int v20; // edi
  unsigned __int8 *v21; // esi
  int *v22; // ecx
  unsigned __int8 *v23; // edi
  int v24; // ebp
  int l; // eax
  int v26; // edx
  int m; // edi
  unsigned int v28; // eax
  unsigned int v29; // ebp
  int n; // eax
  char v31; // cl
  int v32; // ebx
  int v33; // esi
  int *v34; // esi
  unsigned __int8 *v35; // ecx
  int v36; // edi
  int ll; // eax
  int v38; // edx
  int v39; // ebp
  unsigned __int8 *v40; // esi
  unsigned int v41; // eax
  unsigned int v42; // edi
  int mm; // eax
  char v44; // cl
  int *v45; // esi
  unsigned __int8 *v46; // ecx
  int v47; // edi
  int ii; // eax
  int v49; // edx
  int jj; // eax
  int v51; // ecx
  int v52; // edi
  unsigned __int8 *v53; // esi
  unsigned int v54; // eax
  unsigned int v55; // ebp
  int kk; // eax
  char v57; // cl
  unsigned int v58; // edi
  int v59; // eax
  int v60; // esi
  unsigned __int8 *v61; // ebp
  char v62; // cl
  int v63; // [esp+10h] [ebp-4Ch]
  int v64; // [esp+10h] [ebp-4Ch]
  int v65; // [esp+14h] [ebp-48h]
  signed int v66; // [esp+18h] [ebp-44h]
  int v67[4]; // [esp+1Ch] [ebp-40h] BYREF
  unsigned int v68[4]; // [esp+2Ch] [ebp-30h] BYREF
  unsigned int v69[8]; // [esp+3Ch] [ebp-20h] BYREF
  unsigned __int8 *v70; // [esp+60h] [ebp+4h]
  int v71; // [esp+64h] [ebp+8h]

  v68[0] = 305419896;
  v68[1] = 1450727032;
  v68[2] = -1698933128;
  v4 = a2 / 16;
  v7 = a2 & 0x8000000F;
  v5 = (a2 & 0x8000000F) == 0;
  v6 = a2 < 0;
  v68[3] = -553691528;
  v71 = a2 / 16;
  if ( v6 )
  {
    v7 = (((_BYTE)v7 - 1) | 0xFFFFFFF0) + 1;
    v5 = v7 == 0;
  }
  v66 = v7;
  if ( v5 )
  {
    if ( v4 > 0 )
    {
      v8 = a1 - a3;
      v9 = a3;
      v63 = a1 - a3;
      v70 = (unsigned __int8 *)v4;
      while ( 1 )
      {
        v10 = v67;
        v11 = &v9[v8];
        v12 = 4;
        do
        {
          for ( i = 0; i < 4; ++i )
          {
            v14 = (*v10 << 8) ^ v11[i];
            *v10 = v14;
          }
          ++v10;
          v11 += 4;
          --v12;
        }
        while ( v12 );
        encryption(v68, v69, a4);
        for ( j = 0; j < 4; ++j )
        {
          v16 = v69[j];
          v17 = v16 ^ v67[j];
          v68[j] = v16;
          v69[j + 4] = v17;
          for ( k = 0; k < 32; k += 8 )
          {
            v19 = 24 - k;
            *v9++ = v17 >> v19;
          }
        }
        if ( !--v70 )
          break;
        v8 = v63;
      }
    }
  }
  else
  {
    if ( v4 > 0 )
    {
      v20 = a1 - a3;
      v21 = a3;
      v65 = v4;
      while ( 1 )
      {
        v22 = v67;
        v23 = &v21[v20];
        v24 = 4;
        do
        {
          for ( l = 0; l < 4; ++l )
          {
            v26 = (*v22 << 8) ^ v23[l];
            *v22 = v26;
          }
          ++v22;
          v23 += 4;
          --v24;
        }
        while ( v24 );
        encryption(v68, v69, a4);
        for ( m = 0; m < 4; ++m )
        {
          v28 = v69[m];
          v29 = v28 ^ v67[m];
          v68[m] = v28;
          v69[m + 4] = v29;
          for ( n = 0; n < 32; n += 8 )
          {
            v31 = 24 - n;
            *v21++ = v29 >> v31;
          }
        }
        if ( !--v65 )
          break;
        v20 = a1 - a3;
      }
      v4 = v71;
      v7 = v66;
    }
    v32 = v7 / 4;
    v33 = v7 % 4;
    v64 = v33;
    if ( v33 )
    {
      if ( v32 > 0 )
      {
        v45 = v67;
        v46 = &a1[16 * v4];
        v47 = v32;
        do
        {
          for ( ii = 0; ii < 4; ++ii )
          {
            v49 = (*v45 << 8) ^ v46[ii];
            *v45 = v49;
          }
          ++v45;
          v46 += 4;
          --v47;
        }
        while ( v47 );
        v4 = v71;
        v33 = v64;
      }
      for ( jj = 0; jj < v33; v67[v32] = v51 )
        v51 = (v67[v32] << 8) ^ a1[16 * v4 + 4 * v32 + jj++];
      v67[v32] <<= 32 - 8 * v33;
      encryption(v68, v69, a4);
      v52 = 0;
      if ( v32 > 0 )
      {
        v53 = &a3[16 * v4];
        do
        {
          v54 = v69[v52];
          v55 = v54 ^ v67[v52];
          v68[v52] = v54;
          v69[v52 + 4] = v55;
          for ( kk = 0; kk < 32; kk += 8 )
          {
            v57 = 24 - kk;
            *v53++ = v55 >> v57;
          }
          ++v52;
        }
        while ( v52 < v32 );
        v4 = v71;
        v33 = v64;
      }
      v58 = v67[v32] ^ v69[v32];
      v59 = 0;
      v69[v32 + 4] = v58;
      if ( v33 > 0 )
      {
        v60 = 0;
        v61 = &a3[16 * v4 + 4 * v32];
        do
        {
          v62 = 24 - v60;
          v60 += 8;
          v61[v59++] = v58 >> v62;
        }
        while ( v59 < v64 );
      }
    }
    else
    {
      if ( v32 > 0 )
      {
        v34 = v67;
        v35 = &a1[16 * v4];
        v36 = v32;
        do
        {
          for ( ll = 0; ll < 4; ++ll )
          {
            v38 = (*v34 << 8) ^ v35[ll];
            *v34 = v38;
          }
          ++v34;
          v35 += 4;
          --v36;
        }
        while ( v36 );
      }
      encryption(v68, v69, a4);
      v39 = 0;
      if ( v32 > 0 )
      {
        v40 = &a3[16 * v71];
        do
        {
          v41 = v69[v39];
          v42 = v41 ^ v67[v39];
          v68[v39] = v41;
          v69[v39 + 4] = v42;
          for ( mm = 0; mm < 32; mm += 8 )
          {
            v44 = 24 - mm;
            *v40++ = v42 >> v44;
          }
          ++v39;
        }
        while ( v39 < v32 );
      }
    }
  }
}

//----- (00004B20) --------------------------------------------------------
void __cdecl BufDecryptionOFB(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  int v4; // ebp
  bool v5; // zf
  bool v6; // sf
  signed int v7; // esi
  int v8; // edi
  unsigned __int8 *v9; // esi
  int *v10; // ecx
  unsigned __int8 *v11; // edi
  int v12; // ebp
  int i; // eax
  int v14; // edx
  int j; // edi
  unsigned int v16; // eax
  unsigned int v17; // ebp
  int k; // eax
  char v19; // cl
  int v20; // edi
  unsigned __int8 *v21; // esi
  int *v22; // ecx
  unsigned __int8 *v23; // edi
  int v24; // ebp
  int l; // eax
  int v26; // edx
  int m; // edi
  unsigned int v28; // eax
  unsigned int v29; // ebp
  int n; // eax
  char v31; // cl
  int v32; // ebx
  int v33; // esi
  int *v34; // esi
  unsigned __int8 *v35; // ecx
  int v36; // edi
  int ll; // eax
  int v38; // edx
  int v39; // ebp
  unsigned __int8 *v40; // esi
  unsigned int v41; // eax
  unsigned int v42; // edi
  int mm; // eax
  char v44; // cl
  int *v45; // esi
  unsigned __int8 *v46; // ecx
  int v47; // edi
  int ii; // eax
  int v49; // edx
  int jj; // eax
  int v51; // ecx
  int v52; // edi
  unsigned __int8 *v53; // esi
  unsigned int v54; // eax
  unsigned int v55; // ebp
  int kk; // eax
  char v57; // cl
  unsigned int v58; // edi
  int v59; // eax
  int v60; // esi
  unsigned __int8 *v61; // ebp
  char v62; // cl
  int v63; // [esp+10h] [ebp-4Ch]
  int v64; // [esp+10h] [ebp-4Ch]
  int v65; // [esp+14h] [ebp-48h]
  signed int v66; // [esp+18h] [ebp-44h]
  int v67[4]; // [esp+1Ch] [ebp-40h] BYREF
  unsigned int v68[4]; // [esp+2Ch] [ebp-30h] BYREF
  unsigned int v69[8]; // [esp+3Ch] [ebp-20h] BYREF
  unsigned __int8 *v70; // [esp+60h] [ebp+4h]
  int v71; // [esp+64h] [ebp+8h]

  v68[0] = 305419896;
  v68[1] = 1450727032;
  v68[2] = -1698933128;
  v4 = a2 / 16;
  v7 = a2 & 0x8000000F;
  v5 = (a2 & 0x8000000F) == 0;
  v6 = a2 < 0;
  v68[3] = -553691528;
  v71 = a2 / 16;
  if ( v6 )
  {
    v7 = (((_BYTE)v7 - 1) | 0xFFFFFFF0) + 1;
    v5 = v7 == 0;
  }
  v66 = v7;
  if ( v5 )
  {
    if ( v4 > 0 )
    {
      v8 = a1 - a3;
      v9 = a3;
      v63 = a1 - a3;
      v70 = (unsigned __int8 *)v4;
      while ( 1 )
      {
        v10 = v67;
        v11 = &v9[v8];
        v12 = 4;
        do
        {
          for ( i = 0; i < 4; ++i )
          {
            v14 = (*v10 << 8) ^ v11[i];
            *v10 = v14;
          }
          ++v10;
          v11 += 4;
          --v12;
        }
        while ( v12 );
        encryption(v68, v69, a4);
        for ( j = 0; j < 4; ++j )
        {
          v16 = v69[j];
          v17 = v16 ^ v67[j];
          v68[j] = v16;
          v69[j + 4] = v17;
          for ( k = 0; k < 32; k += 8 )
          {
            v19 = 24 - k;
            *v9++ = v17 >> v19;
          }
        }
        if ( !--v70 )
          break;
        v8 = v63;
      }
    }
  }
  else
  {
    if ( v4 > 0 )
    {
      v20 = a1 - a3;
      v21 = a3;
      v65 = v4;
      while ( 1 )
      {
        v22 = v67;
        v23 = &v21[v20];
        v24 = 4;
        do
        {
          for ( l = 0; l < 4; ++l )
          {
            v26 = (*v22 << 8) ^ v23[l];
            *v22 = v26;
          }
          ++v22;
          v23 += 4;
          --v24;
        }
        while ( v24 );
        encryption(v68, v69, a4);
        for ( m = 0; m < 4; ++m )
        {
          v28 = v69[m];
          v29 = v28 ^ v67[m];
          v68[m] = v28;
          v69[m + 4] = v29;
          for ( n = 0; n < 32; n += 8 )
          {
            v31 = 24 - n;
            *v21++ = v29 >> v31;
          }
        }
        if ( !--v65 )
          break;
        v20 = a1 - a3;
      }
      v4 = v71;
      v7 = v66;
    }
    v32 = v7 / 4;
    v33 = v7 % 4;
    v64 = v33;
    if ( v33 )
    {
      if ( v32 > 0 )
      {
        v45 = v67;
        v46 = &a1[16 * v4];
        v47 = v32;
        do
        {
          for ( ii = 0; ii < 4; ++ii )
          {
            v49 = (*v45 << 8) ^ v46[ii];
            *v45 = v49;
          }
          ++v45;
          v46 += 4;
          --v47;
        }
        while ( v47 );
        v4 = v71;
        v33 = v64;
      }
      for ( jj = 0; jj < v33; v67[v32] = v51 )
        v51 = (v67[v32] << 8) ^ a1[16 * v4 + 4 * v32 + jj++];
      v67[v32] <<= 32 - 8 * v33;
      encryption(v68, v69, a4);
      v52 = 0;
      if ( v32 > 0 )
      {
        v53 = &a3[16 * v4];
        do
        {
          v54 = v69[v52];
          v55 = v54 ^ v67[v52];
          v68[v52] = v54;
          v69[v52 + 4] = v55;
          for ( kk = 0; kk < 32; kk += 8 )
          {
            v57 = 24 - kk;
            *v53++ = v55 >> v57;
          }
          ++v52;
        }
        while ( v52 < v32 );
        v4 = v71;
        v33 = v64;
      }
      v58 = v67[v32] ^ v69[v32];
      v59 = 0;
      v69[v32 + 4] = v58;
      if ( v33 > 0 )
      {
        v60 = 0;
        v61 = &a3[16 * v4 + 4 * v32];
        do
        {
          v62 = 24 - v60;
          v60 += 8;
          v61[v59++] = v58 >> v62;
        }
        while ( v59 < v64 );
      }
    }
    else
    {
      if ( v32 > 0 )
      {
        v34 = v67;
        v35 = &a1[16 * v4];
        v36 = v32;
        do
        {
          for ( ll = 0; ll < 4; ++ll )
          {
            v38 = (*v34 << 8) ^ v35[ll];
            *v34 = v38;
          }
          ++v34;
          v35 += 4;
          --v36;
        }
        while ( v36 );
      }
      encryption(v68, v69, a4);
      v39 = 0;
      if ( v32 > 0 )
      {
        v40 = &a3[16 * v71];
        do
        {
          v41 = v69[v39];
          v42 = v41 ^ v67[v39];
          v68[v39] = v41;
          v69[v39 + 4] = v42;
          for ( mm = 0; mm < 32; mm += 8 )
          {
            v44 = 24 - mm;
            *v40++ = v42 >> v44;
          }
          ++v39;
        }
        while ( v39 < v32 );
      }
    }
  }
}

//----- (00004EB0) --------------------------------------------------------
int __cdecl UniperEncFunc(unsigned __int8 *a1, size_t Size, unsigned __int8 *a3, int a4, int a5)
{
  void *v5; // ebx
  unsigned int v7[4]; // [esp+8h] [ebp-130h] BYREF
  unsigned int v8[2]; // [esp+18h] [ebp-120h] BYREF
  char v9[280]; // [esp+20h] [ebp-118h] BYREF

  v5 = _malloc(Size);
  if ( !v5 )
    return 0;
  memset(v5, 0, Size);
  v8[0] = 0;
  v8[1] = 0;
  v7[0] = 0;
  memset(v9, 0, sizeof(v9));
  v7[1] = 0;
  v7[2] = 0;
  v7[3] = 0;
  qmemcpy(v7, a3, a4);
  set_subkey(v7, v8);
  switch ( a5 )
  {
    case 1:
      BufEncryptionECB(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    case 2:
      BufEncryptionCBC(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    case 3:
      BufEncryptionCFB(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    case 4:
      BufEncryptionOFB(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    default:
      break;
  }
  qmemcpy(a1, v5, Size);
  operator delete(v5);
  return 1;
}

//----- (00004FE0) --------------------------------------------------------
int __cdecl UniperDecFunc(unsigned __int8 *a1, size_t Size, unsigned __int8 *a3, int a4, int a5)
{
  void *v5; // ebx
  unsigned int v7[4]; // [esp+8h] [ebp-130h] BYREF
  unsigned int v8[2]; // [esp+18h] [ebp-120h] BYREF
  char v9[280]; // [esp+20h] [ebp-118h] BYREF

  v5 = _malloc(Size);
  if ( !v5 )
    return 0;
  memset(v5, 0, Size);
  v8[0] = 0;
  v8[1] = 0;
  v7[0] = 0;
  memset(v9, 0, sizeof(v9));
  v7[1] = 0;
  v7[2] = 0;
  v7[3] = 0;
  qmemcpy(v7, a3, a4);
  set_subkey(v7, v8);
  switch ( a5 )
  {
    case 1:
      BufDecryptionECB(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    case 2:
      BufDecryptionCBC(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    case 3:
      BufDecryptionCFB(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    case 4:
      BufDecryptionOFB(a1, Size, (unsigned __int8 *)v5, v8);
      break;
    default:
      break;
  }
  qmemcpy(a1, v5, Size);
  operator delete(v5);
  return 1;
}

// nfuncs=15 queued=13 decompiled=13 lumina nreq=0 worse=0 better=0
// ALL OK, 13 function(s) have been successfully decompiled
