/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __cdecl SendLogToXTrapApi(unsigned int, int, unsigned int, unsigned int, unsigned int); // idb
void __cdecl StartXTrapApi(char *, struct _MDL_START_INFO *, struct _MDL_MSG_INFO *); // idb
int __cdecl LoadXTrapApi(unsigned __int8 *); // idb
int __cdecl ExecuteSynchCmdLine(char *a1, unsigned int a2, unsigned int a3, char *a4);
void __cdecl StartXTrapKeepAlive(struct _MDL_MSG_INFO *); // idb
DWORD __stdcall KeepAliveThreadProc(LPVOID lpThreadParameter); // idb
FARPROC __cdecl SetGameInfo(struct _GAME_INFO *a1);
void __cdecl SetKeyboardModule(HINSTANCE, int, void *); // idb
void __cdecl GDaemonMsgCallBackFunc(struct _MDL_MSG_INFO *); // idb
void __cdecl GetRandomKey(unsigned __int8 *, unsigned __int8 *); // idb
int __cdecl HexKeyToString(char *Buffer, int); // idb
void __cdecl SeedKeyExtraction(unsigned __int8 *, unsigned __int8 *); // idb
int __cdecl StringKeyToHex(unsigned __int8 *, int); // idb
void __cdecl SeedKeyGen(char *); // idb
BOOL __cdecl HexToDecimal(char *String, unsigned int *a2);
void __cdecl GetPathName(LPCSTR lpString2, LPSTR lpString1); // idb
void __cdecl TerminateXTrapIC(); // idb
void fcEXP();
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// int __cdecl UniperDecFunc_Buf(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl UniperEncFunc_Buf(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __stdcall Sleep(DWORD dwMilliseconds);
// int _sprintf(char *const Buffer, const char *const Format, ...);
// DWORD __stdcall GetLastError();
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// LRESULT __stdcall DispatchMessageA(const MSG *lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// BOOL __stdcall PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// void __cdecl SendMsgToMgrEx(char *, unsigned int, unsigned int, unsigned int); idb
// DWORD __stdcall GetTickCount();
// int _sscanf(const char *const Buffer, const char *const Format, ...);
// int __cdecl _rand();
// void __cdecl _srand(unsigned int Seed);
// unsigned int __cdecl _strtoul(const char *String, char **EndPtr, int Radix);
// char *__cdecl _strrchr(const char *Str, int Ch);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// HANDLE __stdcall GetCurrentProcess();

//-------------------------------------------------------------------------
// Data declarations

unsigned int g_XTrapStatusFlag; // weak
unsigned int g_XTrapErrorCode; // weak
unsigned int g_XTrapErrorFlag; // weak
HMODULE g_hInstanceXTrapApi; // idb
int g_bXTrapKeepAlive; // weak
HANDLE g_XTrapKeepAliveEvent; // idb
// extern int g_bStartXTrap; weak
// extern int g_bFileCrack; weak
// extern int g_bMemoryCrack; weak
// extern int g_bPatchMdl; weak
// extern int g_bOsMdl; weak
// extern int g_bDebugModMdl; weak
// extern int g_bApiHookMdl; weak
// extern int g_bFileMdl; weak
// extern int g_bSpeedMdl; weak
// extern int g_bMalMdl; weak
// extern int g_bAutoKeybMdl; weak
// extern int g_bAutoMousMdl; weak
// extern int g_bMemoryMdl; weak
// extern int g_bApiMal; weak
// extern unsigned __int8 *Client_HashValue; weak


//----- (00000018) --------------------------------------------------------
void __cdecl SendLogToXTrapApi(unsigned int a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  FARPROC v5; // eax

  if ( g_hInstanceXTrapApi )
  {
    v5 = GetProcAddress(g_hInstanceXTrapApi, "XProc8");
    if ( v5 )
      ((void (__cdecl *)(unsigned int, int, unsigned int, unsigned int, unsigned int))v5)(a1, a2, a3, a4, a5);
  }
}

//----- (00000060) --------------------------------------------------------
void __cdecl StartXTrapApi(char *a1, struct _MDL_START_INFO *a2, struct _MDL_MSG_INFO *a3)
{
  void (*v3)(char *const, const char *const, ...); // esi
  FARPROC v4; // [esp+Ch] [ebp-824h]
  unsigned __int8 v5[257]; // [esp+10h] [ebp-820h] BYREF
  __int16 v6; // [esp+111h] [ebp-71Fh]
  char v7; // [esp+113h] [ebp-71Dh]
  char Buffer; // [esp+114h] [ebp-71Ch] BYREF
  char v9[256]; // [esp+115h] [ebp-71Bh] BYREF
  __int16 v10; // [esp+215h] [ebp-61Bh]
  char v11; // [esp+217h] [ebp-619h]
  unsigned __int8 v12; // [esp+218h] [ebp-618h] BYREF
  char v13[256]; // [esp+219h] [ebp-617h] BYREF
  __int16 v14; // [esp+319h] [ebp-517h]
  char v15; // [esp+31Bh] [ebp-515h]
  char v16; // [esp+31Ch] [ebp-514h] BYREF
  char v17[256]; // [esp+31Dh] [ebp-513h] BYREF
  __int16 v18; // [esp+41Dh] [ebp-413h]
  char v19; // [esp+41Fh] [ebp-411h]
  unsigned __int8 v20; // [esp+420h] [ebp-410h] BYREF
  char v21[256]; // [esp+421h] [ebp-40Fh] BYREF
  __int16 v22; // [esp+521h] [ebp-30Fh]
  char v23; // [esp+523h] [ebp-30Dh]
  unsigned __int8 v24; // [esp+524h] [ebp-30Ch] BYREF
  char v25[256]; // [esp+525h] [ebp-30Bh] BYREF
  __int16 v26; // [esp+625h] [ebp-20Bh]
  char v27; // [esp+627h] [ebp-209h]
  unsigned __int8 v28[257]; // [esp+628h] [ebp-208h] BYREF
  __int16 v29; // [esp+729h] [ebp-107h]
  char v30; // [esp+72Bh] [ebp-105h]
  unsigned __int8 v31; // [esp+72Ch] [ebp-104h] BYREF
  char v32[256]; // [esp+72Dh] [ebp-103h] BYREF
  __int16 v33; // [esp+82Dh] [ebp-3h]
  char v34; // [esp+82Fh] [ebp-1h]

  v31 = 0;
  memset(v32, 0, sizeof(v32));
  v33 = 0;
  v34 = 0;
  v20 = 0;
  memset(v21, 0, sizeof(v21));
  v22 = 0;
  v23 = 0;
  v28[0] = 0;
  memset(&v28[1], 0, 0x100u);
  v29 = 0;
  v30 = 0;
  v24 = 0;
  memset(v25, 0, sizeof(v25));
  v26 = 0;
  v27 = 0;
  v12 = 0;
  memset(v13, 0, sizeof(v13));
  v14 = 0;
  v15 = 0;
  v5[0] = 0;
  memset(&v5[1], 0, 0x100u);
  v6 = 0;
  v7 = 0;
  Buffer = 0;
  memset(v9, 0, sizeof(v9));
  v10 = 0;
  v11 = 0;
  v16 = 0;
  memset(v17, 0, sizeof(v17));
  v3 = (void (*)(char *const, const char *const, ...))_sprintf;
  v18 = 0;
  v19 = 0;
  _sprintf(&Buffer, "%s", "69CB2FD62997E31B");
  v3(&v16, "%s", "39345AEA0DEF4D79");
  GetRandomKey(&v20, v28);
  Sleep(0xAu);
  GetRandomKey(&v12, v5);
  SeedKeyExtraction(&v20, &v31);
  SeedKeyExtraction(&v12, &v24);
  if ( LoadXTrapApi((unsigned __int8 *)a1) )
  {
    if ( g_hInstanceXTrapApi )
    {
      v4 = GetProcAddress(g_hInstanceXTrapApi, "XProc1");
      if ( v4 )
      {
        qmemcpy(a2, v28, 0x20u);
        *((_DWORD *)a2 + 10) = GDaemonMsgCallBackFunc;
        qmemcpy(a3, v5, 0x20u);
        UniperEncFunc_Buf(a2, 1688, &Buffer, 16);
        UniperEncFunc_Buf(a3, 300, &v16, 16);
        ((void (__cdecl *)(struct _MDL_START_INFO *, struct _MDL_MSG_INFO *))v4)(a2, a3);
        UniperDecFunc_Buf(a3, 300, &v24, 16);
      }
      else
      {
        *((_DWORD *)a3 + 9) = 675854;
      }
    }
    else
    {
      *((_DWORD *)a3 + 9) = 368646;
    }
  }
  else
  {
    *((_DWORD *)a3 + 9) = 675851;
  }
}
// 10D4: using guessed type int __cdecl UniperDecFunc_Buf(_DWORD, _DWORD, _DWORD, _DWORD);
// 10D8: using guessed type int __cdecl UniperEncFunc_Buf(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00000304) --------------------------------------------------------
int __cdecl LoadXTrapApi(unsigned __int8 *a1)
{
  int result; // eax
  HMODULE v2; // eax
  char Buffer; // [esp+4h] [ebp-104h] BYREF
  char v4[256]; // [esp+5h] [ebp-103h] BYREF
  __int16 v5; // [esp+105h] [ebp-3h]
  char v6; // [esp+107h] [ebp-1h]

  Buffer = 0;
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  v6 = 0;
  if ( g_hInstanceXTrapApi )
  {
    g_XTrapErrorFlag = 8195;
    result = 0;
  }
  else
  {
    _sprintf(&Buffer, "%s\\%s", (const char *)a1, "XTrapApi.dll");
    v2 = LoadLibraryA(&Buffer);
    if ( v2 )
    {
      g_hInstanceXTrapApi = v2;
      result = 1;
    }
    else
    {
      g_XTrapErrorCode = GetLastError();
      g_XTrapErrorFlag = 8196;
      result = 0;
    }
  }
  return result;
}
// 4: using guessed type unsigned int g_XTrapErrorCode;
// 8: using guessed type unsigned int g_XTrapErrorFlag;

//----- (000003BC) --------------------------------------------------------
int __cdecl ExecuteSynchCmdLine(char *a1, unsigned int a2, unsigned int a3, char *a4)
{
  void (*v4)(char *const, const char *const, ...); // esi
  BOOL v5; // eax
  int result; // eax
  DWORD (__stdcall *v7)(HANDLE, DWORD); // esi
  DWORD v8; // eax
  BOOL (__stdcall *v9)(LPMSG, HWND, UINT, UINT, UINT); // esi
  void (__stdcall *v10)(const MSG *); // edi
  void (__stdcall *v11)(const MSG *); // ebp
  DWORD ExitCode; // [esp+8h] [ebp-27Ch] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+Ch] [ebp-278h] BYREF
  struct tagMSG Msg; // [esp+1Ch] [ebp-268h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+38h] [ebp-24Ch] BYREF
  CHAR CommandLine; // [esp+7Ch] [ebp-208h] BYREF
  char v17[256]; // [esp+7Dh] [ebp-207h] BYREF
  __int16 v18; // [esp+17Dh] [ebp-107h]
  char v19; // [esp+17Fh] [ebp-105h]
  char Buffer; // [esp+180h] [ebp-104h] BYREF
  char v21[256]; // [esp+181h] [ebp-103h] BYREF
  __int16 v22; // [esp+281h] [ebp-3h]
  char v23; // [esp+283h] [ebp-1h]

  CommandLine = 0;
  memset(v17, 0, sizeof(v17));
  v18 = 0;
  v19 = 0;
  Buffer = 0;
  memset(v21, 0, sizeof(v21));
  v22 = 0;
  v23 = 0;
  v4 = (void (*)(char *const, const char *const, ...))_sprintf;
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  ProcessInformation.hProcess = 0;
  ProcessInformation.hThread = 0;
  ProcessInformation.dwProcessId = 0;
  ProcessInformation.dwThreadId = 0;
  StartupInfo.cb = 68;
  StartupInfo.wShowWindow = 1;
  _sprintf(&Buffer, "%s\\XPatch.exe", a1);
  v4(&CommandLine, "XPatch.exe *%08d*%08X*%s*", a3, a2, a4);
  v5 = CreateProcessA(&Buffer, &CommandLine, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation);
  if ( v5 )
  {
    ExitCode = 0;
    if ( v5 )
    {
      v7 = WaitForSingleObject;
      do
        v8 = v7(ProcessInformation.hProcess, 0x1Eu);
      while ( v8 == 258 );
      if ( v8 != 128 && v8 != -1 )
      {
        v9 = PeekMessageA;
        if ( PeekMessageA(&Msg, 0, 0, 0, 1u) )
        {
          v10 = (void (__stdcall *)(const MSG *))TranslateMessage;
          v11 = (void (__stdcall *)(const MSG *))DispatchMessageA;
          do
          {
            v10(&Msg);
            v11(&Msg);
          }
          while ( v9(&Msg, 0, 0, 0, 1u) );
        }
      }
    }
    GetExitCodeProcess(ProcessInformation.hProcess, &ExitCode);
    if ( ExitCode == 256 )
    {
      result = 1;
    }
    else
    {
      g_XTrapErrorCode = ExitCode;
      g_XTrapErrorFlag = 8194;
      result = 0;
    }
  }
  else
  {
    g_XTrapErrorCode = GetLastError();
    g_XTrapErrorFlag = 8193;
    result = 0;
  }
  return result;
}
// 4: using guessed type unsigned int g_XTrapErrorCode;
// 8: using guessed type unsigned int g_XTrapErrorFlag;

//----- (000005A8) --------------------------------------------------------
void __cdecl StartXTrapKeepAlive(struct _MDL_MSG_INFO *a1)
{
  HANDLE v1; // eax
  DWORD ThreadId; // [esp+0h] [ebp-4h] BYREF

  ThreadId = 0;
  v1 = CreateEventA(0, 0, 0, 0);
  if ( v1 )
  {
    g_XTrapKeepAliveEvent = v1;
    if ( CreateThread(0, 0, KeepAliveThreadProc, 0, 0, &ThreadId) )
    {
      *((_DWORD *)a1 + 9) = 2;
    }
    else
    {
      g_XTrapErrorCode = GetLastError();
      g_XTrapErrorFlag = 8198;
    }
  }
  else
  {
    g_XTrapErrorCode = GetLastError();
    g_XTrapErrorFlag = 8197;
  }
}
// 4: using guessed type unsigned int g_XTrapErrorCode;
// 8: using guessed type unsigned int g_XTrapErrorFlag;

//----- (00000628) --------------------------------------------------------
DWORD __stdcall KeepAliveThreadProc(LPVOID lpThreadParameter)
{
  DWORD (__stdcall *v1)(HANDLE, DWORD); // esi
  DWORD v2; // eax
  char Buffer[500]; // [esp+0h] [ebp-1F4h] BYREF

  v1 = WaitForSingleObject;
  v2 = WaitForSingleObject(g_XTrapKeepAliveEvent, 0x1D4C0u);
  if ( v2 != -1 )
  {
    while ( v2 != 128 && v2 )
    {
      if ( v2 == 258 )
      {
        if ( !g_bXTrapKeepAlive )
        {
          _sprintf(
            Buffer,
            "%04x.%d.%08x.%08x.(%d)",
            g_XTrapStatusFlag,
            g_bStartXTrap,
            g_XTrapErrorFlag,
            g_XTrapErrorCode,
            1);
          SendMsgToMgrEx(Buffer, 0x11u, 0, 5u);
          break;
        }
        g_bXTrapKeepAlive = 0;
      }
      v2 = v1(g_XTrapKeepAliveEvent, 0x1D4C0u);
      if ( v2 == -1 )
        break;
    }
  }
  if ( g_XTrapKeepAliveEvent )
    CloseHandle(g_XTrapKeepAliveEvent);
  g_XTrapKeepAliveEvent = 0;
  TerminateXTrapIC();
  return 1;
}
// 0: using guessed type unsigned int g_XTrapStatusFlag;
// 4: using guessed type unsigned int g_XTrapErrorCode;
// 8: using guessed type unsigned int g_XTrapErrorFlag;
// 10: using guessed type int g_bXTrapKeepAlive;
// 1114: using guessed type int g_bStartXTrap;

//----- (00000710) --------------------------------------------------------
FARPROC __cdecl SetGameInfo(struct _GAME_INFO *a1)
{
  FARPROC result; // eax
  char v2; // [esp+4h] [ebp-12Ch] BYREF
  char v3[296]; // [esp+5h] [ebp-12Bh] BYREF
  __int16 v4; // [esp+12Dh] [ebp-3h]
  char v5; // [esp+12Fh] [ebp-1h]

  v2 = 0;
  memset(v3, 0, sizeof(v3));
  v4 = 0;
  v5 = 0;
  result = (FARPROC)g_hInstanceXTrapApi;
  if ( g_hInstanceXTrapApi )
  {
    result = GetProcAddress(g_hInstanceXTrapApi, "XProc3");
    if ( result )
    {
      ((void (__cdecl *)(struct _GAME_INFO *, char *))result)(a1, &v2);
      result = (FARPROC)(*(_DWORD *)&v3[35] == 2);
    }
  }
  return result;
}

//----- (00000788) --------------------------------------------------------
void __cdecl SetKeyboardModule(HINSTANCE a1, int a2, void *a3)
{
  FARPROC v3; // eax

  if ( g_hInstanceXTrapApi )
  {
    v3 = GetProcAddress(g_hInstanceXTrapApi, "XProc7");
    if ( v3 )
      ((void (__cdecl *)(HINSTANCE, int, void *))v3)(a1, a2, a3);
  }
}

//----- (000007C0) --------------------------------------------------------
void __cdecl GDaemonMsgCallBackFunc(struct _MDL_MSG_INFO *a1)
{
  int v1; // eax
  int v2; // eax
  unsigned int v3; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ecx
  int v6; // eax
  int v7; // eax
  unsigned int v8; // [esp+8h] [ebp-518h] BYREF
  char Buffer[257]; // [esp+Ch] [ebp-514h] BYREF
  __int16 v10; // [esp+10Dh] [ebp-413h]
  char v11; // [esp+10Fh] [ebp-411h]
  char v12[257]; // [esp+110h] [ebp-410h] BYREF
  __int16 v13; // [esp+211h] [ebp-30Fh]
  char v14; // [esp+213h] [ebp-30Dh]
  char String[4]; // [esp+214h] [ebp-30Ch] BYREF
  int v16; // [esp+218h] [ebp-308h]
  __int16 v17; // [esp+315h] [ebp-20Bh]
  char v18; // [esp+317h] [ebp-209h]
  unsigned __int8 v19[257]; // [esp+318h] [ebp-208h] BYREF
  __int16 v20; // [esp+419h] [ebp-107h]
  char v21; // [esp+41Bh] [ebp-105h]
  unsigned __int8 v22; // [esp+41Ch] [ebp-104h] BYREF
  char v23[256]; // [esp+41Dh] [ebp-103h] BYREF
  __int16 v24; // [esp+51Dh] [ebp-3h]
  char v25; // [esp+51Fh] [ebp-1h]

  v1 = *((_DWORD *)a1 + 9);
  if ( v1 == 5 || v1 == 368644 )
    g_bXTrapKeepAlive = 1;
  v2 = *((_DWORD *)a1 + 9);
  if ( v2 == 6 || v2 == 368646 )
  {
    v19[0] = 0;
    memset(&v19[1], 0, 0x100u);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    memset(v23, 0, sizeof(v23));
    v24 = 0;
    v25 = 0;
    memset(&Buffer[1], 0, 0x100u);
    v10 = 0;
    v11 = 0;
    String[0] = 0;
    memset(&String[1], 0, 0x100u);
    v17 = 0;
    v18 = 0;
    v8 = 0;
    v3 = GetTickCount();
    qmemcpy(v19, (char *)a1 + 44, 0x40u);
    qmemcpy(Buffer, (char *)a1 + 108, 0x50u);
    SeedKeyExtraction(v19, &v22);
    HexKeyToString(Buffer, 40);
    UniperDecFunc_Buf(Buffer, 40, &v22, 16);
    memset(&v12[1], 0, 0x100u);
    v13 = 0;
    v14 = 0;
    qmemcpy(v12, Buffer, 0x20u);
    *(_DWORD *)String = *(_DWORD *)&Buffer[32];
    v16 = *(_DWORD *)&Buffer[36];
    HexToDecimal(String, &v8);
    if ( v8 > v3 || v8 + 500 < v3 )
      Sleep(1u);
    HexKeyToString(v12, 16);
    v4 = *(unsigned __int8 **)&v12[8];
    Client_HashValue = *(unsigned __int8 **)v12;
    v5 = *(unsigned __int8 **)&v12[12];
    *(&Client_HashValue + 1) = *(unsigned __int8 **)&v12[4];
    *(&Client_HashValue + 2) = v4;
    *(&Client_HashValue + 3) = v5;
  }
  v6 = *((_DWORD *)a1 + 8);
  if ( v6 == 1 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bApiMal = 1;
  }
  else if ( v6 == 2 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bMemoryMdl = 1;
  }
  else if ( v6 == 3 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bAutoMousMdl = 1;
  }
  else if ( v6 == 4 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bAutoKeybMdl = 1;
  }
  else if ( v6 == 5 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bMalMdl = 1;
  }
  else if ( v6 == 6 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bSpeedMdl = 1;
  }
  else if ( v6 == 7 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bFileMdl = 1;
  }
  else if ( v6 == 8 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bApiHookMdl = 1;
  }
  else if ( v6 == 9 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bDebugModMdl = 1;
  }
  else if ( v6 == 19 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bOsMdl = 1;
  }
  else if ( v6 == 16 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bPatchMdl = 1;
  }
  else if ( v6 == 48 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bMemoryCrack = 1;
  }
  else if ( v6 == 49 && *((_DWORD *)a1 + 9) == 4 && !*((_DWORD *)a1 + 10) )
  {
    g_bFileCrack = 1;
  }
  v7 = *((_DWORD *)a1 + 8);
  if ( v7 == 1 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bApiMal = 1;
  }
  else if ( v7 == 256 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bMemoryMdl = 1;
  }
  else if ( v7 == 257 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bAutoMousMdl = 1;
  }
  else if ( v7 == 258 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bAutoKeybMdl = 1;
  }
  else if ( v7 == 259 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bMalMdl = 1;
  }
  else if ( v7 == 260 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bSpeedMdl = 1;
  }
  else if ( v7 == 261 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bFileMdl = 1;
  }
  else if ( v7 == 263 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bApiHookMdl = 1;
  }
  else if ( v7 == 265 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bDebugModMdl = 1;
  }
  else if ( v7 == 0x10000 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bOsMdl = 1;
  }
  else if ( v7 == 266 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bPatchMdl = 1;
  }
  else if ( v7 == 4352 && *((_DWORD *)a1 + 9) == 675843 && !*((_DWORD *)a1 + 10) )
  {
    g_bMemoryCrack = 1;
  }
}
// 10: using guessed type int g_bXTrapKeepAlive;
// 10D4: using guessed type int __cdecl UniperDecFunc_Buf(_DWORD, _DWORD, _DWORD, _DWORD);
// 1118: using guessed type int g_bFileCrack;
// 111C: using guessed type int g_bMemoryCrack;
// 1120: using guessed type int g_bPatchMdl;
// 1124: using guessed type int g_bOsMdl;
// 1128: using guessed type int g_bDebugModMdl;
// 112C: using guessed type int g_bApiHookMdl;
// 1130: using guessed type int g_bFileMdl;
// 1134: using guessed type int g_bSpeedMdl;
// 1138: using guessed type int g_bMalMdl;
// 113C: using guessed type int g_bAutoKeybMdl;
// 1140: using guessed type int g_bAutoMousMdl;
// 1144: using guessed type int g_bMemoryMdl;
// 1148: using guessed type int g_bApiMal;
// 114C: using guessed type unsigned __int8 *Client_HashValue;

//----- (00000C80) --------------------------------------------------------
void __cdecl GetRandomKey(unsigned __int8 *a1, unsigned __int8 *a2)
{
  char Buffer[257]; // [esp+8h] [ebp-104h] BYREF
  __int16 v3; // [esp+109h] [ebp-3h]
  char v4; // [esp+10Bh] [ebp-1h]

  Buffer[0] = 0;
  memset(&Buffer[1], 0, 0x100u);
  v3 = 0;
  v4 = 0;
  SeedKeyGen(Buffer);
  qmemcpy(a1, Buffer, 0x40u);
  HexKeyToString(Buffer, 64);
  qmemcpy(a2, Buffer, 0x20u);
}

//----- (00000CF0) --------------------------------------------------------
int __cdecl HexKeyToString(char *Buffer, int a2)
{
  int v2; // esi
  char *v3; // ebx
  int (*v4)(const char *const, const char *const, ...); // edi
  char v6; // [esp+10h] [ebp-84h] BYREF
  __int16 v7; // [esp+11h] [ebp-83h]
  char v8; // [esp+14h] [ebp-80h] BYREF
  char v9[124]; // [esp+15h] [ebp-7Fh] BYREF
  __int16 v10; // [esp+91h] [ebp-3h]
  char v11; // [esp+93h] [ebp-1h]

  v8 = 0;
  memset(v9, 0, sizeof(v9));
  v10 = 0;
  v2 = 0;
  v6 = 0;
  v7 = 0;
  v11 = 0;
  if ( a2 > 0 )
  {
    v3 = Buffer;
    v4 = _sscanf;
    do
    {
      if ( v4(v3, "%02X", &v6) == -1 )
        break;
      v3 += 2;
      *(&v8 + v2++) = v6;
    }
    while ( v2 < a2 );
  }
  qmemcpy(Buffer, &v8, a2);
  return 1;
}

//----- (00000D98) --------------------------------------------------------
void __cdecl SeedKeyExtraction(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // eax
  int *v3; // ecx
  int v4; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  char v8; // [esp+3h] [ebp-51h]
  __int128 v9; // [esp+4h] [ebp-50h]
  int v10[16]; // [esp+14h] [ebp-40h] BYREF

  v2 = 0;
  v9 = 0ui64;
  v10[0] = 4;
  v10[1] = 9;
  v10[2] = 14;
  v10[3] = 15;
  v10[4] = 16;
  v10[5] = 20;
  v10[6] = 22;
  v10[7] = 27;
  v10[8] = 29;
  v10[9] = 33;
  v10[10] = 35;
  v10[11] = 38;
  v10[12] = 51;
  v10[13] = 55;
  v10[14] = 57;
  v10[15] = 62;
  v3 = v10;
  do
  {
    v4 = *v3;
    ++v2;
    ++v3;
    *(&v8 + v2) = a1[v4];
  }
  while ( v2 < 16 );
  v5 = DWORD1(v9);
  *(_DWORD *)a2 = v9;
  v6 = DWORD2(v9);
  *((_DWORD *)a2 + 1) = v5;
  v7 = HIDWORD(v9);
  *((_DWORD *)a2 + 2) = v6;
  *((_DWORD *)a2 + 3) = v7;
}

//----- (00000E78) --------------------------------------------------------
int __cdecl StringKeyToHex(unsigned __int8 *a1, int a2)
{
  int v2; // ebx
  char Buffer; // [esp+10h] [ebp-84h] BYREF
  __int16 v5; // [esp+11h] [ebp-83h]
  char v6; // [esp+14h] [ebp-80h] BYREF
  char v7[124]; // [esp+15h] [ebp-7Fh] BYREF
  __int16 v8; // [esp+91h] [ebp-3h]
  char v9; // [esp+93h] [ebp-1h]

  v2 = 0;
  v6 = 0;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  Buffer = 0;
  v5 = 0;
  v9 = 0;
  if ( a2 > 0 )
  {
    do
    {
      _sprintf(&Buffer, "%.02X", a1[v2]);
      strcat(&v6, &Buffer);
      ++v2;
    }
    while ( v2 < a2 );
  }
  qmemcpy(a1, &v6, 2 * a2);
  return 1;
}

//----- (00000F40) --------------------------------------------------------
void __cdecl SeedKeyGen(char *a1)
{
  unsigned int v1; // eax
  unsigned __int16 (__cdecl *v2)(); // ebx
  int v3; // ebp
  int v4; // esi
  int v5; // eax
  char Buffer; // [esp+10h] [ebp-200h] BYREF
  char v7[252]; // [esp+11h] [ebp-1FFh] BYREF
  __int16 v8; // [esp+10Dh] [ebp-103h]
  char v9[253]; // [esp+110h] [ebp-100h] BYREF
  __int16 v10; // [esp+20Dh] [ebp-3h]

  Buffer = 0;
  v9[0] = 0;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  memset(&v9[1], 0, 0xFCu);
  v10 = 0;
  v1 = GetTickCount();
  _srand(v1);
  v2 = (unsigned __int16 (__cdecl *)())_rand;
  v3 = 8;
  do
  {
    v4 = v2();
    v5 = ((int (__cdecl *)())v2)();
    _sprintf(&Buffer, "%08X", v4 | (v5 << 16));
    strcat(v9, &Buffer);
    --v3;
  }
  while ( v3 );
  qmemcpy(a1, v9, 0x40u);
}

//----- (00001018) --------------------------------------------------------
BOOL __cdecl HexToDecimal(char *String, unsigned int *a2)
{
  unsigned int v2; // eax

  v2 = _strtoul(String, &String, 16);
  *a2 = v2;
  return v2 != -1;
}

//----- (00001048) --------------------------------------------------------
void __cdecl GetPathName(LPCSTR lpString2, LPSTR lpString1)
{
  char *v2; // eax

  lstrcpyA(lpString1, lpString2);
  v2 = _strrchr(lpString1, 92);
  if ( v2 )
    *v2 = 0;
  else
    *lpString1 = 0;
}

//----- (00001078) --------------------------------------------------------
void __cdecl TerminateXTrapIC()
{
  HANDLE v0; // eax

  v0 = GetCurrentProcess();
  TerminateProcess(v0, 0);
}

//----- (00001088) --------------------------------------------------------
void fcEXP()
{
  ;
}

// nfuncs=44 queued=18 decompiled=18 lumina nreq=0 worse=0 better=0
// ALL OK, 18 function(s) have been successfully decompiled
